ALTER TABLE sh_zustaendigkeit RENAME TO v_sh_zustaendigkeit;

ALTER TABLE roh_ue_person_albv_leistung RENAME TO roh_ue_person_albv;
ALTER TABLE ue_person_albv_leistung RENAME TO ue_person_albv;
ALTER TABLE sec_ue_person_albv_leistung RENAME TO sec_ue_person_albv;

ALTER TABLE roh_antragsteller_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;
ALTER TABLE antragsteller_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;
ALTER TABLE sec_antragsteller_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;

ALTER TABLE roh_ue_person_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;
ALTER TABLE ue_person_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;
ALTER TABLE sec_ue_person_albv RENAME COLUMN betrag_tot_auszahlung TO betrag_tot_auszahlungen;

ALTER TABLE roh_sh_dossier RENAME COLUMN betrag_ausbezahlt_zuschuss_gem TO betrag_ausbez_zuschuss_gem;
ALTER TABLE sh_dossier RENAME COLUMN betrag_ausbezahlt_zuschuss_gem TO betrag_ausbez_zuschuss_gem;
ALTER TABLE sec_sh_dossier RENAME COLUMN betrag_ausbezahlt_zuschuss_gem TO betrag_ausbez_zuschuss_gem;

ALTER TABLE roh_sh_dossier ADD version INTEGER DEFAULT 0;
ALTER TABLE sh_dossier ADD version INTEGER DEFAULT 0;
ALTER TABLE sec_sh_dossier ADD version INTEGER DEFAULT 0;

ALTER TABLE v_beruf ADD gueltig_ab_datum DATE NULL;
ALTER TABLE v_beruf ADD gueltig_ab_version VARCHAR2(32) NULL;

UPDATE v_plausi SET where_bedingung = Replace(where_bedingung, 'sh_zustaendigkeit', 'v_sh_zustaendigkeit')
WHERE plausi_id IN (15115, 15117, 15118, 15119);

UPDATE v_plausi SET from_bedingung = Replace(from_bedingung, 'ue_person_albv_leistung', 'ue_person_albv'), where_bedingung = Replace(where_bedingung, 'ue_person_albv_leistung', 'ue_person_albv');

UPDATE v_plausi SET where_bedingung = Replace(where_bedingung, 'betrag_tot_auszahlung', 'betrag_tot_auszahlungen');
UPDATE v_plausi SET where_bedingung = Replace(where_bedingung, 'betrag_ausbezahlt_zuschuss_gem', 'betrag_ausbez_zuschuss_gem');

UPDATE v_plausi SET update_bedingung = Replace(update_bedingung, 'betrag_ausbezahlt_zuschuss_gem', 'betrag_ausbez_zuschuss_gem');
UPDATE v_plausi SET select_wert_vor_update = Replace(select_wert_vor_update, 'betrag_ausbezahlt_zuschuss_gem', 'betrag_ausbez_zuschuss_gem');

UPDATE bereinigungsfilter SET filter_tabelle = 'ue_person_albv' WHERE filter_tabelle = 'ue_person_albv_leistung';
UPDATE bereinigungsfilter SET abhaengig_tabelle = REPLACE(abhaengig_tabelle, 'ue_person_albv_leistung', 'ue_person_albv') WHERE abhaengig_tabelle like '%ue_person_albv_leistung%';
UPDATE bereinigungsfilter SET abhaengig_attribut = REPLACE(abhaengig_attribut, 'ue_person_albv_leistung', 'ue_person_albv') WHERE abhaengig_tabelle like '%ue_person_albv%';

UPDATE bereinigungsfilter SET zusatzbedingungen = REPLACE(zusatzbedingungen, 'ue_person_albv_leistung', 'ue_person_albv')
WHERE bereinigungsfilter_id IN
(
select bereinigungsfilter_id from bereinigungsfilter where zusatzbedingungen like '%ue_person_albv_leistung%'
);

UPDATE bereinigungsfilter SET filter_attribut = REPLACE(filter_attribut, 'betrag_tot_auszahlung', 'betrag_tot_auszahlungen'), abhaengig_attribut =  REPLACE(abhaengig_attribut, 'betrag_tot_auszahlung', 'betrag_tot_auszahlungen'), zusatzbedingungen = REPLACE(zusatzbedingungen,'betrag_tot_auszahlung', 'betrag_tot_auszahlungen')
WHERE bereinigungsfilter_id IN
(
select bereinigungsfilter_id from bereinigungsfilter where (zusatzbedingungen like '%betrag_tot_ausz%' OR filter_attribut like '%betrag_tot_ausz%' OR abhaengig_attribut like '%betrag_tot_ausz%')
AND ( filter_tabelle IN ('antragsteller_albv', 'ue_person_albv') OR abhaengig_tabelle IN ('antragsteller_albv', 'ue_person_albv'))
);

UPDATE bereinigungsfilter SET abhaengig_attribut = REPLACE(abhaengig_attribut, 'betrag_ausbezahlt_zuschuss_gem', 'betrag_ausbez_zuschuss_gem'), zusatzbedingungen = REPLACE(zusatzbedingungen,'betrag_ausbezahlt_zuschuss_gem', 'betrag_ausbez_zuschuss_gem') 
WHERE bereinigungsfilter_id IN
(
select bereinigungsfilter_id from bereinigungsfilter where (zusatzbedingungen like '%betrag_ausbezahlt_zuschuss_gem%' OR abhaengig_attribut like '%betrag_ausbezahlt_zuschuss_gem%')
);


  CREATE OR REPLACE FORCE VIEW "ISOS"."VW_NICHTLEEREANTRAGSTELLER" ("SH_DOSSIER_ID", "UE_PERSON_ID", "ANTRAGSART_ID", "BETRAG_ZUGESPROCHEN", "DAT_ERSTE_AUSZAHLUNG", "BETRAG_TOT_AUSZAHLUNGEN", "B_BEZUG_STICHTAG", "DAT_LETZTE_ZAHLUNG") AS 
  SELECT aal.sh_dossier_id, NULL AS ue_person_id, aal.antragsart_id, aal.betrag_zugesprochen, aal.dat_erste_auszahlung, aal.betrag_tot_auszahlungen,
aal.b_bezug_stichtag, aal.dat_letzte_zahlung
FROM antragsteller_albv aal
RIGHT OUTER JOIN
antragsteller a ON a.sh_dossier_id = aal.sh_dossier_id 
WHERE     (aal.antragsart_id >= 0) OR
          (aal.betrag_zugesprochen > 0) OR
          (aal.dat_erste_auszahlung < TO_DATE('01.01.9998', 'DD.MM.YYYY')) OR
          (aal.betrag_tot_auszahlungen > 0) OR
          (aal.b_bezug_stichtag >= 0) OR
          (aal.dat_letzte_zahlung < TO_DATE('01.01.9998', 'DD.MM.YYYY'));



CREATE OR REPLACE VIEW VW_NichtLeereUePersonen (
   sh_dossier_id,
   ue_person_id,
   antragsart_id,
   betrag_zugesprochen,
   dat_erste_auszahlung,
   betrag_tot_auszahlungen,
   b_bezug_stichtag,
   dat_letzte_zahlung )
AS
SELECT upal.sh_dossier_id, upal.ue_person_id, upal.antragsart_id, upal.betrag_zugesprochen, upal.dat_erste_auszahlung, upal.betrag_tot_auszahlungen,
upal.b_bezug_stichtag, upal.dat_letzte_zahlung
FROM ue_person_albv upal
RIGHT OUTER JOIN
ue_person up ON (up.sh_dossier_id = upal.sh_dossier_id AND up.ue_person_id = upal.ue_person_id)
WHERE     (upal.antragsart_id >= 0) OR
          (upal.betrag_zugesprochen > 0) OR
          (upal.dat_erste_auszahlung < TO_DATE('01.01.9998', 'DD.MM.YYYY')) OR
          (upal.betrag_tot_auszahlungen > 0) OR
          (upal.b_bezug_stichtag >= 0) OR
          (upal.dat_letzte_zahlung < TO_DATE('01.01.9998', 'DD.MM.YYYY'))
/


CREATE OR REPLACE VIEW VW_NichtLeerePersonen (
   sh_dossier_id,
   ue_person_id,
   antragsart_id,
   betrag_zugesprochen,
   dat_erste_auszahlung,
   betrag_tot_auszahlungen,
   b_bezug_stichtag,
   dat_letzte_zahlung )
AS
SELECT     SH_DOSSIER_ID, UE_PERSON_ID, ANTRAGSART_ID, BETRAG_ZUGESPROCHEN, DAT_ERSTE_AUSZAHLUNG,
           BETRAG_TOT_AUSZAHLUNGEN, B_BEZUG_STICHTAG, DAT_LETZTE_ZAHLUNG
FROM       VW_NichtLeereAntragsteller
UNION
SELECT     SH_DOSSIER_ID, UE_PERSON_ID, ANTRAGSART_ID, BETRAG_ZUGESPROCHEN, DAT_ERSTE_AUSZAHLUNG,
           BETRAG_TOT_AUSZAHLUNGEN, B_BEZUG_STICHTAG, DAT_LETZTE_ZAHLUNG
FROM       VW_NichtLeereUePersonen
/

UPDATE v_plausi set from_bedingung = REPLACE(where_bedingung, 'VW_NichtLeereAntragsteller.betrag_tot_auszahlung', 'VW_NichtLeereAntragsteller.betrag_tot_auszahlungen');
UPDATE v_plausi set from_bedingung = REPLACE(where_bedingung, 'VW_NichtLeereUePersonen.betrag_tot_auszahlung', 'VW_NichtLeereUePersonen.betrag_tot_auszahlungen');
UPDATE v_plausi set from_bedingung = REPLACE(where_bedingung, 'VW_NichtLeerePersonen.betrag_tot_auszahlung', 'VW_NichtLeerePersonen.betrag_tot_auszahlungen');

CREATE OR REPLACE FORCE VIEW "ISOS"."VW_DBL_ALBV" ("ID", "SLT", "GEM", "BZK", "KTN", "NB_UA", "VERS_DEM", "GBT_DEM", "DFP_DEM", "DLP_DEM", "UE_ID1", "VERS_UE1", "GBT_UE1", "DFP_UE1", "DLP_UE1", "UE_ID2", "VERS_UE2", "GBT_UE2", "DFP_UE2", "DLP_UE2", "UE_ID3", "VERS_UE3", "GBT_UE3", "DFP_UE3", "DLP_UE3", "UE_ID4", "VERS_UE4", "GBT_UE4", "DFP_UE4", "DLP_UE4", "UE_ID5", "VERS_UE5", "GBT_UE5", "DFP_UE5", "DLP_UE5", "UE_ID6", "VERS_UE6", "GBT_UE6", "DFP_UE6", "DLP_UE6", "DFP_CUM", "DLP_CUM") AS 
  SELECT "ID",
    "SLT",
    "GEM",
    "BZK",
    "KTN",
    "NB_UA",
    "VERS_DEM",
    "GBT_DEM",
    "DFP_DEM",
    "DLP_DEM",
    "UE_ID1",
    "VERS_UE1",
    "GBT_UE1",
    "DFP_UE1",
    "DLP_UE1",
    "UE_ID2",
    "VERS_UE2",
    "GBT_UE2",
    "DFP_UE2",
    "DLP_UE2",
    "UE_ID3",
    "VERS_UE3",
    "GBT_UE3",
    "DFP_UE3",
    "DLP_UE3",
    "UE_ID4",
    "VERS_UE4",
    "GBT_UE4",
    "DFP_UE4",
    "DLP_UE4",
    "UE_ID5",
    "VERS_UE5",
    "GBT_UE5",
    "DFP_UE5",
    "DLP_UE5",
    "UE_ID6",
    "VERS_UE6",
    "GBT_UE6",
    "DFP_UE6",
    "DLP_UE6",
    "DFP_CUM",
    "DLP_CUM"
  FROM
    ( SELECT DISTINCT TBL_PILOTE.id,
      TBL_PILOTE.slt,
      TBL_PILOTE.gem,
      TBL_PILOTE.bzk,
      TBL_PILOTE.ktn,
      TBL_PILOTE.nb_ua,
      TBL_PILOTE.vers_dem,
      TBL_PILOTE.gbt_dem,
      TBL_PILOTE.dfp_dem,
      TBL_PILOTE.dlp_dem,
      UE_1.ue_id1,
      UE_1.vers_ue1,
      UE_1.gbt_ue1,
      UE_1.dfp_ue1,
      UE_1.dlp_ue1,
      UE_2.ue_id2,
      UE_2.vers_ue2,
      UE_2.gbt_ue2,
      UE_2.dfp_ue2,
      UE_2.dlp_ue2,
      UE_3.ue_id3,
      UE_3.vers_ue3,
      UE_3.gbt_ue3,
      UE_3.dfp_ue3,
      UE_3.dlp_ue3,
      UE_4.ue_id4,
      UE_4.vers_ue4,
      UE_4.gbt_ue4,
      UE_4.dfp_ue4,
      UE_4.dlp_ue4,
      UE_5.ue_id5,
      UE_5.vers_ue5,
      UE_5.gbt_ue5,
      UE_5.dfp_ue5,
      UE_5.dlp_ue5,
      UE_6.ue_id6,
      UE_6.vers_ue6,
      UE_6.gbt_ue6,
      UE_6.dfp_ue6,
      UE_6.dlp_ue6,
      CASE
        WHEN UE_1.ue_id1 IS NULL
        THEN NULL
        WHEN UE_2.ue_id2 IS NULL
        THEN UE_1.dfp_ue1
        WHEN UE_3.ue_id3 IS NULL
        THEN LEAST(UE_1.dfp_ue1, UE_2.dfp_ue2)
        WHEN UE_4.ue_id4 IS NULL
        THEN LEAST(UE_1.dfp_ue1, UE_2.dfp_ue2, UE_3.dfp_ue3)
        WHEN UE_5.ue_id5 IS NULL
        THEN LEAST(UE_1.dfp_ue1, UE_2.dfp_ue2, UE_3.dfp_ue3, UE_4.dfp_ue4)
        WHEN UE_6.ue_id6 IS NULL
        THEN LEAST(UE_1.dfp_ue1, UE_2.dfp_ue2, UE_3.dfp_ue3, UE_4.dfp_ue4, UE_5.dfp_ue5)
        ELSE LEAST(UE_1.dfp_ue1, UE_2.dfp_ue2, UE_3.dfp_ue3, UE_4.dfp_ue4, UE_5.dfp_ue5, UE_6.dfp_ue6)
      END AS dfp_cum,
      CASE
        WHEN UE_1.ue_id1 IS NULL
        THEN NULL
        WHEN UE_2.ue_id2 IS NULL
        THEN UE_1.dlp_ue1
        WHEN UE_3.ue_id3 IS NULL
        THEN LEAST(UE_1.dlp_ue1, UE_2.dlp_ue2)
        WHEN UE_4.ue_id4 IS NULL
        THEN LEAST(UE_1.dlp_ue1, UE_2.dlp_ue2, UE_3.dlp_ue3)
        WHEN UE_5.ue_id5 IS NULL
        THEN LEAST(UE_1.dlp_ue1, UE_2.dlp_ue2, UE_3.dlp_ue3, UE_4.dlp_ue4)
        WHEN UE_6.ue_id6 IS NULL
        THEN LEAST(UE_1.dlp_ue1, UE_2.dlp_ue2, UE_3.dlp_ue3, UE_4.dlp_ue4, UE_5.dlp_ue5)
        ELSE LEAST(UE_1.dlp_ue1, UE_2.dlp_ue2, UE_3.dlp_ue3, UE_4.dlp_ue4, UE_5.dlp_ue5, UE_6.dlp_ue6)
      END AS dlp_cum
    FROM
      (SELECT TBL.id,
        TBL.slt,
        TBL.gem,
        TBL.bzk,
        TBL.ktn,
        TBL.nb_ua,
        TBL.vers_dem,
        TBL.gbt_dem,
        TBL.dfp_dem,
        TBL.dlp_dem
      FROM
        ( SELECT DISTINCT dos.sh_dossier_id                   AS id,
          dos.sozialleistungstraeger_id                       AS slt,
          gem.name                                            AS gem,
          bzk.name                                            AS bzk,
          gem.kanton_id                                       AS ktn,
          dos.anz_personen_ue                                 AS nb_ua,
          ant.versichertennummer                              AS vers_dem,
          ant.dat_geburt                                      AS gbt_dem,
          ant_a.dat_erste_auszahlung                          AS dfp_dem,
          ant_a.dat_letzte_zahlung                            AS dlp_dem,
          COUNT(*) OVER (PARTITION BY ant.versichertennummer) AS cnt
        FROM SH_DOSSIER dos
        INNER JOIN ANTRAGSTELLER ant
        ON (dos.sh_dossier_id = ant.sh_dossier_id)
        INNER JOIN ANTRAGSTELLER_ALBV ant_a
        ON (ant_a.sh_dossier_id = dos.sh_dossier_id)
        INNER JOIN V_GEMEINDE gem
        ON (gem.gemeinde_id = dos.gemeinde_id)
        INNER JOIN V_BEZIRK bzk
        ON (bzk.bezirk_id           = gem.bezirk_id
        AND bzk.kanton_id           = gem.kanton_id)
        WHERE dos.b_neubezuegerrecord = 1
        AND dos.sh_leistungstyp_id  = 25
        AND ant.versichertennummer NOT LIKE '%-%'
        AND dos.sh_flustat_id is null
        ) TBL
      WHERE TBL.cnt > 1
      ) TBL_PILOTE
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id1,
        ue.versichertennummer     AS vers_ue1,
        ue.geburtsjahr            AS gbt_ue1,
        ue_a.dat_erste_auszahlung AS dfp_ue1,
        ue_a.dat_letzte_zahlung   AS dlp_ue1
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 1
      OR ue.ue_person_id    IS NULL)
      ) UE_1 ON UE_1.id      = TBL_PILOTE.id
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id2,
        ue.versichertennummer     AS vers_ue2,
        ue.geburtsjahr            AS gbt_ue2,
        ue_a.dat_erste_auszahlung AS dfp_ue2,
        ue_a.dat_letzte_zahlung   AS dlp_ue2
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 2
      OR ue.ue_person_id    IS NULL)
      ) UE_2 ON UE_2.id      = TBL_PILOTE.id
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id3,
        ue.versichertennummer     AS vers_ue3,
        ue.geburtsjahr            AS gbt_ue3,
        ue_a.dat_erste_auszahlung AS dfp_ue3,
        ue_a.dat_letzte_zahlung   AS dlp_ue3
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 3
      OR ue.ue_person_id    IS NULL)
      ) UE_3 ON UE_3.id      = TBL_PILOTE.id
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id4,
        ue.versichertennummer     AS vers_ue4,
        ue.geburtsjahr            AS gbt_ue4,
        ue_a.dat_erste_auszahlung AS dfp_ue4,
        ue_a.dat_letzte_zahlung   AS dlp_ue4
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 4
      OR ue.ue_person_id    IS NULL)
      ) UE_4 ON UE_4.id      = TBL_PILOTE.id
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id5,
        ue.versichertennummer     AS vers_ue5,
        ue.geburtsjahr            AS gbt_ue5,
        ue_a.dat_erste_auszahlung AS dfp_ue5,
        ue_a.dat_letzte_zahlung   AS dlp_ue5
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 5
      OR ue.ue_person_id    IS NULL)
      ) UE_5 ON UE_5.id      = TBL_PILOTE.id
    LEFT OUTER JOIN
      (SELECT ue.sh_dossier_id    AS id,
        ue.ue_person_id           AS ue_id6,
        ue.versichertennummer     AS vers_ue6,
        ue.geburtsjahr            AS gbt_ue6,
        ue_a.dat_erste_auszahlung AS dfp_ue6,
        ue_a.dat_letzte_zahlung   AS dlp_ue6
      FROM UE_PERSON ue
      INNER JOIN ue_person_albv ue_a
      ON (ue.sh_dossier_id   = ue_a.sh_dossier_id
      AND ue.ue_person_id    = ue_a.ue_person_id)
      WHERE (ue.ue_person_id = 6
      OR ue.ue_person_id    IS NULL)
      ) UE_6 ON UE_6.id      = TBL_PILOTE.id
    ORDER BY TBL_PILOTE.vers_dem ASC,
      TBL_PILOTE.dlp_dem DESC,
      TBL_PILOTE.dfp_dem DESC
    ) TEMP_2
  ORDER BY TEMP_2.vers_dem ASC,
    TEMP_2.dlp_dem DESC,
    TEMP_2.dfp_dem DESC,
    TEMP_2.dlp_cum DESC,
    TEMP_2.dfp_cum DESC;
/

create or replace 
PACKAGE DBO IS 

   FUNCTION FC_TEST_VERSICHERTENNUMMER (p_vers_nummer IN VARCHAR2) RETURN INTEGER;
   FUNCTION FC_IS_ALBV_KANTON(p_sozialleistungstraeger IN VARCHAR2) RETURN INTEGER;
   FUNCTION FC_IS_6_MT_BETWEEN(pFromDate IN DATE, pToDate IN DATE) RETURN INTEGER;
   FUNCTION FC_BFS_CODE(p_plz_id VARCHAR2) RETURN INTEGER;
   FUNCTION FC_ISNUMERIC(param VARCHAR2) RETURN BOOLEAN;
   FUNCTION FC_TMJ(tt INTEGER, mm INTEGER, jjjj INTEGER) RETURN DATE;
   FUNCTION FC_LEFT(str VARCHAR2, len INTEGER) RETURN VARCHAR2;
END DBO;
/

create or replace 
PACKAGE BODY DBO IS

FUNCTION FC_TEST_VERSICHERTENNUMMER (p_vers_nummer IN VARCHAR2)
RETURN INTEGER
IS

sVersichertennummer VARCHAR2(32);
iResult INTEGER;
iPos INTEGER;
iLen INTEGER;
iProduct INTEGER;
iEvenSum INTEGER;
iOddSum INTEGER;
iSum INTEGER;
iDiff INTEGER;

BEGIN
iResult := 0;

sVersichertennummer := p_vers_nummer;
sVersichertennummer := REPLACE(sVersichertennummer,'.','');

iLen := LENGTH(sVersichertennummer);

IF iLen = 13 THEN
BEGIN
  IF(SUBSTR(sVersichertennummer, 1, 3) <> '756')
  THEN
  BEGIN
      iResult := 0;
      RETURN iResult;
  END;
  END IF;

   -- STEP 1
  iPos := 2;
  iEvenSum := 0;

  WHILE iPos < iLen
  LOOP
   iEvenSum := iEvenSum + TO_NUMBER(SUBSTR(sVersichertennummer, iPos, 1));
   iPos := iPos + 2;
  END LOOP;

  -- STEP 2
  iProduct := iEvenSum * 3;

  -- STEP 3
  iPos := 1;
  iOddSum := 0;

  WHILE iPos < iLen
  LOOP
   iOddSum := iOddSum + TO_NUMBER(SUBSTR(sVersichertennummer, iPos, 1));
   iPos := iPos + 2;
  END LOOP;

  -- STEP 4
  iSum := iProduct + iOddSum;

  -- STEP 5
  iDiff := (10 - iSum MOD 10) MOD 10;

   -- STEP 6
  IF (TO_NUMBER(SUBSTR(sVersichertennummer, 13, 1)) = iDiff) THEN
    iResult := 1;
  END IF;
END;
ELSE
   iResult := 0;
END IF;

RETURN iResult;

END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_IS_ALBV_KANTON(p_sozialleistungstraeger IN VARCHAR2) RETURN INTEGER
IS
    iKanton INTEGER;
    bAlbvKanton INTEGER;
    sSTlong VARCHAR2(12);

BEGIN
    sSTlong := '000000' || p_sozialleistungstraeger;
    iKanton := TO_NUMBER(SUBSTR(SUBSTR(sSTlong, -6,6),1,2));

    IF iKanton IN (9,10,22,23,24,25,26) THEN
         bAlbvKanton := 1;
    ELSE
        bAlbvKanton := 0;
    END IF;

    RETURN bAlbvKanton;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_IS_6_MT_BETWEEN(pFromDate IN DATE, pToDate IN DATE) RETURN INTEGER
IS
    iResult INTEGER;
    fm INTEGER;
    tm INTEGER;
    fy INTEGER;
    ty INTEGER;
    diffMt INTEGER;
BEGIN
    iResult := 0;

    IF  pFromDate IS NOT NULL
        AND pToDate IS NOT NULL
        AND pFromDate < TO_DATE('01.01.9998', 'DD.MM.YYYY') AND pToDate < TO_DATE('01.01.9998', 'DD.MM.YYYY') THEN
    BEGIN
        fy := EXTRACT ( YEAR FROM pFromDate);
        ty := EXTRACT ( YEAR FROM pToDate);
        fm := EXTRACT ( MONTH FROM pFromDate);
        tm := EXTRACT ( MONTH FROM pToDate);
        diffMt := (12*ty + tm) - (12*fy + fm);

        IF diffMt = 6 THEN
            iResult := 0;
        ELSE
            iResult := 1;
        END IF;
    END;
    END IF;

    RETURN iResult;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */
FUNCTION FC_BFS_CODE(p_plz_id VARCHAR2) RETURN INTEGER
IS
    bfs_code INTEGER;
    l_count INTEGER;

BEGIN
    l_count := 0;

    IF  LENGTH(p_plz_id) = 8 THEN
        BEGIN
            SELECT COUNT(1) INTO l_count FROM v_plz_neu WHERE  plz_id = p_plz_id;
            IF l_count > 0 THEN
                SELECT gemeinde_id INTO bfs_code FROM v_plz_neu WHERE plz_id = p_plz_id;
            END IF;
        END;
    ELSE
        bfs_code := CASE WHEN FC_ISNUMERIC(p_plz_id) THEN TO_NUMBER(p_plz_id) ELSE NULL END;
    END IF;

    RETURN bfs_code;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_ISNUMERIC (param VARCHAR2) RETURN BOOLEAN
IS
   dummy number;
BEGIN
   dummy:=to_number(param);
   RETURN true;
EXCEPTION
   WHEN OTHERS THEN
       RETURN false;
END;

FUNCTION FC_TMJ(tt INTEGER, mm INTEGER, jjjj INTEGER)  RETURN DATE
IS
l_date DATE;

BEGIN
  
  l_date := TO_DATE(tt || '.' || mm || '.' || jjjj, 'DD.MM.JJJJ');
  
  return l_date;
  
END;

FUNCTION FC_TO_DATE(str VARCHAR2) RETURN DATE
IS
BEGIN

  return TO_DATE(str, 'DD.MM.YYYY');
  
END;

FUNCTION FC_LEFT(str VARCHAR2, len INTEGER)  RETURN VARCHAR2
IS
BEGIN
  
  IF length(str) = 0 THEN
    return LPAD(' ', len-1);
  ELSE
   return substr(str,1,len);
  END IF;
  
  --return l_str;
  
END;

FUNCTION FC_YEAR(d DATE) RETURN INTEGER
IS
BEGIN

  return Extract(year from d);
  
END;

FUNCTION FC_MONTH(d DATE) RETURN INTEGER
IS
BEGIN

  return Extract(month from d);
  
END;

FUNCTION FC_TODAY RETURN DATE
IS
BEGIN

  return SYSDATE;
END;

FUNCTION FC_ISNULLDATE(d1 DATE, d2 DATE) RETURN DATE
IS
BEGIN
  
  return NVL(d1,d2);
  
END;

FUNCTION FC_ISNULL_int(i1 INTEGER, i2 INTEGER) RETURN INTEGER
IS
BEGIN
  
  return NVL(i1,i2);
  
END;

END DBO;
/

create or replace 
PACKAGE BODY do_test
IS

/* --------------------------------------------------------------------------

    ISOS 6.4
    ***********
    Version 1.1  26.04.2013 Oliver Heiler
                Neue Funktion FC_IS_ALBV_KANTON
                Neue Funktion FC_IS_6_MT_BETWEEN(pFromDate
                Neue Funktion FC_BFS_CODE(p_plz_id VARCHAR2)
                Neue Funktion FC_ISNUMERIC(param VARCHAR2)
    Grund: Harmonisierung ISOS und Plausex Plausibilisierung
* -------------------------------------------------------------------------- */


/* --------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.00   28.10.2008   Oliver Heiler, Concevis AG
   Grund:         Eliminierung nicht mehr benötiger Codes Missing Codes nur noch
                  -3 (echtes Missing), -65, -68 fallen weg.
* -------------------------------------------------------------------------- */

FUNCTION FC_MISSING(p_code INTEGER) RETURN INTEGER

IS

BEGIN
   IF (  p_code = -3  ) THEN

      RETURN 1;

   END IF;

   RETURN 0;

END;

FUNCTION FC_MISSING(p_code INTEGER, p_variable_typ_id INTEGER) RETURN INTEGER

IS

BEGIN
   IF ( p_variable_typ_id = 3) THEN
   BEGIN
         IF (  p_code = -16  ) THEN
            RETURN 1;
         END IF;
   END;
   ELSE
       IF (  p_code = -3  ) THEN

       RETURN 1;

       END IF;
   END IF;

   RETURN 0;

END;


--------------------------------------------------------------------------------
FUNCTION FC_MISSING(p_string VARCHAR2) RETURN INTEGER

IS

BEGIN

      RETURN FC_MISSING(TO_NUMBER(p_string));

EXCEPTION
   WHEN VALUE_ERROR THEN
      RETURN 0;
END;

FUNCTION FC_MISSING(p_string VARCHAR2, p_variable_typ_id INTEGER) RETURN INTEGER

IS

BEGIN

      RETURN FC_MISSING(TO_NUMBER(p_string) , p_variable_typ_id);

EXCEPTION
   WHEN VALUE_ERROR THEN
      RETURN 0;
END;

--------------------------------------------------------------------------------

FUNCTION   FC_MISSING_AHV_NR(p_ahv_nr VARCHAR2) RETURN INTEGER

IS

l_result    INTEGER := 0;

BEGIN

   IF ( p_ahv_nr IN (C_PROB_AHV_CHIFFRE1, C_PROB_AHV_CHIFFRE2, C_PROB_AHV_MISSING_CHIFFRE) ) THEN

      l_result := 1;

   ELSE

      l_result := FC_MISSING(TO_NUMBER(p_ahv_nr));

   END IF;

   RETURN l_result;

EXCEPTION
   WHEN VALUE_ERROR THEN
      RETURN 0;
END;


--------------------------------------------------------------------------------
/* --------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.00   28.10.2008   Oliver Heiler, Concevis AG
   Grund:         Eliminierung nicht mehr benötiger Codes Missing Codes nur noch
                  -3 (echtes Missing), -65, -68 fallen weg.
* -------------------------------------------------------------------------- */



FUNCTION FC_MISSING(p_date DATE) RETURN INTEGER

IS

year  INTEGER := NULL;

BEGIN

   year := TO_CHAR(p_date, 'YYYY');

   IF ( year = 9999 ) THEN
          IF (  p_date = TO_DATE('03.01.9999','DD.MM.YYYY')) THEN

                 RETURN 1;

          END IF;
   END IF;

   RETURN 0;

END;

FUNCTION FC_MISSING(p_date DATE, p_variable_typ_id INTEGER) RETURN INTEGER

IS

year  INTEGER := NULL;

BEGIN

   year := TO_CHAR(p_date, 'YYYY');

   IF ( year = 9999 ) THEN
          IF (  p_date = TO_DATE('03.01.9999','DD.MM.YYYY')) THEN

                 RETURN 1;

          END IF;
   END IF;

   RETURN 0;

END;

--------------------------------------------------------------------------------

FUNCTION FC_NOT_MISSING(p_code INTEGER) RETURN INTEGER

IS

BEGIN

   IF ( p_code IS NULL ) THEN

      RETURN 0;

   ELSE

      RETURN 1;

   END IF;

END;

--------------------------------------------------------------------------------

FUNCTION FC_NOT_MISSING(p_string VARCHAR2) RETURN INTEGER

IS

BEGIN

   RETURN FC_NOT_MISSING(TO_NUMBER(p_string));

EXCEPTION
   WHEN VALUE_ERROR THEN
      RETURN 1;

END;

--------------------------------------------------------------------------------

FUNCTION FC_NOT_MISSING(p_date DATE) RETURN INTEGER

IS

BEGIN

   IF ( p_date IS NULL ) THEN

      RETURN 0;

   ELSE

      RETURN 1;

   END IF;

END;

--------------------------------------------------------------------------------

FUNCTION FC_SPEZ_CODE(p_date DATE) RETURN INTEGER

IS

BEGIN

   IF ( TO_NUMBER(TO_CHAR(p_date, 'YYYY')) >= 9999 ) THEN

      RETURN 1;

   END IF;

   RETURN 0;

END;

--------------------------------------------------------------------------------


FUNCTION FC_LEISTUNGSKLASSE(p_sh_leistungstyp_id roh_sh_dossier.sh_leistungstyp_id%TYPE) RETURN INTEGER
/* --------------------------------------------------------------------------
   ISOS 4.1
   ********
   Version 1.01   19.03.2008   Olivier Wirz BFS
   Grund:         Ab EP 2007 gehoert Leistungstyp 6 (Zuschuss nach Dekret) zur
                  Leistungsklasse 13 und nicht mehr 1
   ISOS 5.0
   ********
   Version 2.0    20.11.2009  Oliver Heiler Concevis AG
   Grund:         Hardcodierung eliminierung und über Join v_sh_leistungsklasse/
                  v_sh_leistungstyp ermitteln
* -------------------------------------------------------------------------- */
IS

klasse_id   INTEGER := NULL;

BEGIN

   SELECT DISTINCT sh_leistungsklasse_id INTO klasse_id FROM v_sh_leistungstyp
   WHERE sh_leistungstyp_id = p_sh_leistungstyp_id;

   RETURN klasse_id;

   EXCEPTION
    WHEN NO_DATA_FOUND THEN RETURN NULL;

   /*SELECT DECODE(p_sh_leistungstyp_id,
      1,1, 2,1, 3,1, 4,1, 5,1, 6,13,
      10,2, 20,99, 21,99, 22,99, 23,6,
      24,99, 25,8, 26,99, 30,99, 31,99,
      32,12, 33,12, 34,12, 35,13, 36,13, 37,13, NULL)
   INTO klasse_id
   FROM DUAL;*/



END;


--------------------------------------------------------------------------------

FUNCTION FC_UNTERB(erstbezug1 DATE, letztbezug1 DATE, erstbezug2 DATE, letztbezug2 DATE) RETURN FLOAT

IS

unterb1     FLOAT := NULL;
unterb2     FLOAT := NULL;

BEGIN

   IF ( FC_SPEZ_CODE(erstbezug1) + FC_SPEZ_CODE(letztbezug2) <= 0 ) THEN

      unterb1 := MONTHS_BETWEEN(erstbezug1, letztbezug2);

   ELSE

      unterb1 := -3;

   END IF;

   IF ( FC_SPEZ_CODE(erstbezug2) + FC_SPEZ_CODE(letztbezug1) <= 0 ) THEN

      unterb2 := MONTHS_BETWEEN(erstbezug2, letztbezug1);

   ELSE

      unterb2 := -3;

   END IF;

   RETURN GREATEST(unterb1, unterb2);

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_FALL_NR(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

fall_nr  VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(d.gemeinde_id) || '#'
      || TO_CHAR(d.sozialleistungstraeger_id) || '#'
      || TO_CHAR(FC_LEISTUNGSKLASSE(d.sh_leistungstyp_id)) || '#'
      || TO_CHAR(d.jahr) || '#'
      || TO_CHAR(d.dossiernummer)
   INTO fall_nr
   FROM roh_sh_dossier d
   WHERE d.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(d.gemeinde_id) = 0
   AND FC_MISSING(d.sozialleistungstraeger_id) = 0
   AND FC_MISSING(d.sh_leistungstyp_id) = 0
   AND FC_MISSING(d.jahr) = 0
   AND FC_MISSING(d.dossiernummer) = 0;

   RETURN fall_nr;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_GBGZN(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbgzn VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.zivilstand_id) || '#'
      || TO_CHAR(a.nationalitaet_land_id)
   INTO gbgzn
   FROM roh_antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.zivilstand_id) = 0
   AND FC_MISSING(a.nationalitaet_land_id) = 0;

   RETURN gbgzn;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;
END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_GBGZ(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbgz VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.zivilstand_id)
   INTO gbgz
   FROM roh_antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.zivilstand_id) = 0
   AND FC_MISSING(a.nationalitaet_land_id) = 0;

   RETURN gbgz;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_GBGN(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbgn VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.nationalitaet_land_id)
   INTO gbgn
   FROM roh_antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.zivilstand_id) = 0
   AND FC_MISSING(a.nationalitaet_land_id) = 0;

   RETURN gbgn;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_KURZ_NR(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

kurz_nr VARCHAR2(1024) := NULL;

BEGIN

    SELECT TO_CHAR(d.sozialleistungstraeger_id)|| '#'
        || TO_CHAR(d.dossiernummer)
    INTO kurz_nr
    FROM roh_sh_dossier d
    WHERE d.sh_dossier_id = p_sh_dossier_id
    AND FC_MISSING(d.sozialleistungstraeger_id) = 0
    AND FC_MISSING(d.dossiernummer) = 0;

    RETURN kurz_nr;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_GBG(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbg VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt) || '#' || TO_CHAR(a.geschlecht_id)
   INTO gbg
   FROM roh_antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0;

   RETURN gbg;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_ROH_BEZ_UNTERB(p_sh_dossier1_id INTEGER, p_sh_dossier2_id INTEGER) RETURN FLOAT

IS

erstbezug1     DATE := NULL;
erstbezug2     DATE := NULL;
letztbezug1    DATE := NULL;
letztbezug2    DATE := NULL;
datum1         DATE := NULL;
datum2         DATE := NULL;

BEGIN

   SELECT d.dat_erste_auszahlung, d.dat_letzte_zahlung
   INTO erstbezug1, letztbezug1
   FROM roh_sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier1_id;

   SELECT d.dat_erste_auszahlung, d.dat_letzte_zahlung
   INTO erstbezug2, letztbezug2
   FROM roh_sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier2_id;

   RETURN FC_UNTERB(erstbezug1, letztbezug1, erstbezug2, letztbezug2);

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_FALL_NR(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

fall_nr  VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(d.gemeinde_id) || '#'
      || TO_CHAR(d.sozialleistungstraeger_id) || '#'
      || TO_CHAR(FC_LEISTUNGSKLASSE(d.sh_leistungstyp_id)) || '#'
      || TO_CHAR(d.jahr) || '#'
      || TO_CHAR(d.dossiernummer)
   INTO fall_nr
   FROM sh_dossier d
   WHERE d.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(d.gemeinde_id) = 0
   AND FC_MISSING(d.sozialleistungstraeger_id) = 0
   AND FC_MISSING(d.sh_leistungstyp_id) = 0
   AND FC_MISSING(d.jahr) = 0
   AND FC_MISSING(d.dossiernummer) = 0;

   RETURN fall_nr;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_GBGZN(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbgzn VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.zivilstand_id) || '#'
      || TO_CHAR(a.nationalitaet_land_id)
   INTO gbgzn
   FROM antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.zivilstand_id) = 0
   AND FC_MISSING(a.nationalitaet_land_id) = 0;

   RETURN gbgzn;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;
END;

--------------------------------------------------------------------------------

FUNCTION FC_GBGZ(p_sh_dossier_id INTEGER) RETURN VARCHAR2
/* --------------------------------------------------------------------------
   ISOS 4.1
   ********
   Version 1.01   11.09.2008   Olivier Wirz BFS
   Grund:         Klausel
                     AND FC_MISSING(a.nationalitaet_land_id) = 0
                  gelöscht
* -------------------------------------------------------------------------- */
IS

gbgz VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.zivilstand_id)
   INTO gbgz
   FROM antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.zivilstand_id) = 0;

   RETURN gbgz;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END FC_GBGZ;

--------------------------------------------------------------------------------

FUNCTION FC_GBGN(p_sh_dossier_id INTEGER) RETURN VARCHAR2
/* --------------------------------------------------------------------------
   ISOS 4.1
   ********
   Version 1.01   11.09.2008   Olivier Wirz BFS
   Grund:         Klausel
                     AND FC_MISSING(a.zivilstand_id) = 0
                  gelöscht
* -------------------------------------------------------------------------- */
IS

gbgn VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.nationalitaet_land_id)
   INTO gbgn
   FROM antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(a.nationalitaet_land_id) = 0;

   RETURN gbgn;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END FC_GBGN;
--------------------------------------------------------------------------------

FUNCTION FC_KURZ_NR(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

kurz_nr VARCHAR2(1024) := NULL;

BEGIN

    SELECT TO_CHAR(d.sozialleistungstraeger_id)|| '#'
        || TO_CHAR(d.dossiernummer)
    INTO kurz_nr
    FROM sh_dossier d
    WHERE d.sh_dossier_id = p_sh_dossier_id
    AND FC_MISSING(d.sozialleistungstraeger_id) = 0
    AND FC_MISSING(d.dossiernummer) = 0;

    RETURN kurz_nr;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_GBG(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

gbg VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt) || '#' || TO_CHAR(a.geschlecht_id)
   INTO gbg
   FROM antragsteller a
   WHERE a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0;

   RETURN gbg;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_BEZ_UNTERB(p_sh_dossier1_id INTEGER, p_sh_dossier2_id INTEGER) RETURN FLOAT

IS

erstbezug1     DATE := NULL;
erstbezug2     DATE := NULL;
letztbezug1    DATE := NULL;
letztbezug2    DATE := NULL;
datum1         DATE := NULL;
datum2         DATE := NULL;

BEGIN

   SELECT d.dat_erste_auszahlung, d.dat_letzte_zahlung
   INTO erstbezug1, letztbezug1
   FROM sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier1_id;

   SELECT d.dat_erste_auszahlung, d.dat_letzte_zahlung
   INTO erstbezug2, letztbezug2
   FROM sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier2_id;

   RETURN FC_UNTERB(erstbezug1, letztbezug1, erstbezug2, letztbezug2);

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_COUNT_MISS(p_sh_dossier_id INTEGER) RETURN INTEGER

IS

count_miss  INTEGER := NULL;

BEGIN

   SELECT
   (
      SELECT
      DO_TEST.FC_MISSING(sh_dossier.anz_personen_hh) + DO_TEST.FC_MISSING(sh_dossier.anz_personen_ue) +
      DO_TEST.FC_MISSING(sh_dossier.betrag_zugesprochen) + DO_TEST.FC_MISSING(sh_dossier.dat_erste_auszahlung) +
      DO_TEST.FC_MISSING(sh_dossier.betrag_tot_einmalzahlungen) + DO_TEST.FC_MISSING(sh_dossier.betrag_tot_auszahlungen) +
      DO_TEST.FC_MISSING(sh_dossier.b_bezug_stichtag) + DO_TEST.FC_MISSING(sh_dossier.dat_letzte_zahlung)
      FROM sh_dossier
      WHERE sh_dossier_id = p_sh_dossier_id ) +
   (
      SELECT NVL(
      DO_TEST.FC_MISSING(antragsteller.zvr_gemeinde_id) + DO_TEST.FC_MISSING(antragsteller.dat_geburt) +
      DO_TEST.FC_MISSING(antragsteller.geschlecht_id) + DO_TEST.FC_MISSING(antragsteller.nationalitaet_land_id) +
      DO_TEST.FC_MISSING(antragsteller.b_allein_im_hh) , 0)
      FROM antragsteller RIGHT OUTER JOIN DUAL
      ON DUMMY = 'X'
      WHERE sh_dossier_id = p_sh_dossier_id
   ) +
   (
      SELECT
      NVL(SUM(DO_TEST.FC_MISSING(erwerbsituation_id)), 0)
      FROM antragsteller_erwerbsit
      WHERE sh_dossier_id = p_sh_dossier_id ) +
   (
      SELECT
      NVL(SUM(DO_TEST.FC_MISSING(verwandtschaftsgrad_id)), 0)
      FROM ue_person
      WHERE sh_dossier_id = p_sh_dossier_id
   )
   INTO count_miss
   FROM DUAL;

   RETURN count_miss;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;
/*
    SELECT DO_TEST.FC_MISSING(antragsteller.zvr_gemeinde_id) + DO_TEST.FC_MISSING(antragsteller.dat_geburt) + DO_TEST.FC_MISSING(antragsteller.geschlecht_id) + DO_TEST.FC_MISSING(antragsteller.nationalitaet_land_id) +
    DO_TEST.FC_MISSING(antragsteller.b_allein_im_hh) + DO_TEST.FC_MISSING(sh_dossier.anz_personen_hh) + DO_TEST.FC_MISSING(sh_dossier.anz_personen_ue) +
    DO_TEST.FC_MISSING(sh_dossier.betrag_zugesprochen) + DO_TEST.FC_MISSING(sh_dossier.dat_erste_auszahlung) + DO_TEST.FC_MISSING(sh_dossier.betrag_tot_einmalzahlungen) +
    DO_TEST.FC_MISSING(sh_dossier.betrag_tot_auszahlungen) + DO_TEST.FC_MISSING(sh_dossier.b_bezug_stichtag) + DO_TEST.FC_MISSING(sh_dossier.dat_letzte_zahlung) +
    DO_TEST.FC_MISSING( antragsteller_erwerbsit.erwerbsituation1_id) + DO_TEST.FC_MISSING( antragsteller_erwerbsit.erwerbsituation2_id) + DO_TEST.FC_MISSING( antragsteller_erwerbsit.erwerbsituation3_id) + DO_TEST.FC_MISSING( antragsteller_erwerbsit.erwerbsituation4_id) +
    DO_TEST.FC_MISSING(verwgrad.v_1_1) + DO_TEST.FC_MISSING(verwgrad.v_1_2) + DO_TEST.FC_MISSING(verwgrad.v_1_3) + DO_TEST.FC_MISSING(verwgrad.v_1_4) + DO_TEST.FC_MISSING(verwgrad.v_1_5) + DO_TEST.FC_MISSING(verwgrad.v_1_6) + DO_TEST.FC_MISSING(verwgrad.v_1_7) +
    DO_TEST.FC_MISSING(verwgrad.v_1_8) + DO_TEST.FC_MISSING(verwgrad.v_1_9)
    INTO count_miss
    FROM sh_dossier, antragsteller,
        (

            SELECT sh_dossier_id,  MAX(DECODE(seq, 1, erwerbsituation_id, NULL)) AS erwerbsituation1_id, MAX(DECODE(seq, 2, erwerbsituation_id, NULL)) AS erwerbsituation2_id,
                                   MAX(DECODE(seq, 3, erwerbsituation_id, NULL)) AS erwerbsituation3_id, MAX(DECODE(seq, 4, erwerbsituation_id, NULL)) AS erwerbsituation4_id
            FROM ( SELECT rae.sh_dossier_id, rae.erwerbsituation_id, row_number() OVER ( PARTITION BY sh_dossier_id ORDER BY erwerbsituation_id ) seq FROM antragsteller_erwerbsit rae )
            WHERE seq <= 4
           GROUP BY sh_dossier_id
        )
        antragsteller_erwerbsit,
        (

            SELECT sh_dossier_id, MAX(DECODE(seq1, 1, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_1, MAX(DECODE(seq1, 2, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_2, MAX(DECODE(seq1, 3, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_3,
            MAX(DECODE(seq1, 4, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_4, MAX(DECODE(seq1, 5, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_5, MAX(DECODE(seq1, 6, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_6, MAX(DECODE(seq1, 7, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_7,
            MAX(DECODE(seq1, 8, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_8, MAX(DECODE(seq1, 9, sh_dossier.verwandtschaftsgrad_id, NULL)) v_1_9
            FROM
            (
                SELECT sh_dossier_id, verwandtschaftsgrad_id, row_number() OVER (PARTITION BY sh_dossier_id ORDER BY ue_person_id) seq1 FROM ue_person
            ) sh_dossier
            GROUP BY sh_dossier_id
        ) verwgrad
    WHERE  sh_dossier.sh_dossier_id = p_sh_dossier_id
    AND sh_dossier.sh_dossier_id = antragsteller.sh_dossier_id
    AND sh_dossier.sh_dossier_id = antragsteller_erwerbsit.sh_dossier_id (+) -- Jörn Wilkens, 31.01.05, Ergänzung des Outer Join Operators
    AND sh_dossier.sh_dossier_id = verwgrad.sh_dossier_id (+);

    RETURN count_miss;
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;
*/
END;

--------------------------------------------------------------------------------

-- < 0,  falls Dossier 1 "schlechter" ist als Dossier 2
-- = 0,  falls beide Dossiers "gleich" sin
-- > 0,  falls Dossier 1 "besser" ist als Dossier 2
FUNCTION FC_CMP_DAT_ERSTE_AUSZ(p_sh_dossier1_id INTEGER, p_sh_dossier2_id INTEGER) RETURN INTEGER

IS

l_dat1      sh_dossier.dat_erste_auszahlung%TYPE;
l_dat2      sh_dossier.dat_erste_auszahlung%TYPE;

BEGIN

   SELECT MAX( DECODE(sh_dossier_id, p_sh_dossier1_id, dat_erste_auszahlung, NULL) ),
      MAX( DECODE(sh_dossier_id, p_sh_dossier2_id, dat_erste_auszahlung, NULL) )
   INTO l_dat1, l_dat2
   FROM sh_dossier
   WHERE sh_dossier_id IN (p_sh_dossier1_id, p_sh_dossier2_id);

   IF ( FC_MISSING(l_dat1) + FC_MISSING(l_dat2) >= 1 ) THEN

      RETURN 0;

   END IF;

   IF ( l_dat1 < l_dat2 ) THEN

      RETURN -1;

   ELSIF ( l_dat1 > l_dat2 ) THEN

      RETURN 1;

   END IF;

   RETURN 0;

END;

--------------------------------------------------------------------------------

FUNCTION FC_CMP_DAT_AUFNAHME(p_sh_dossier1_id INTEGER, p_sh_dossier2_id INTEGER) RETURN INTEGER

IS

dat_aufnahme1    DATE := NULL;
dat_aufnahme2    DATE := NULL;

BEGIN

   SELECT d.dat_aufnahme
   INTO dat_aufnahme1
   FROM sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier1_id;

   SELECT d.dat_aufnahme
   INTO dat_aufnahme2
   FROM sh_dossier d
   WHERE sh_dossier_id = p_sh_dossier2_id;

   IF ( ( FC_MISSING( dat_aufnahme1 ) = 0 ) AND ( FC_MISSING( dat_aufnahme2 ) = 0 ) ) THEN
        IF (dat_aufnahme1 < dat_aufnahme2) THEN

            RETURN 1;

        ELSIF (dat_aufnahme1 > dat_aufnahme2) THEN

            RETURN 2;
        ELSE

            RETURN 0;
        END IF;
    ELSE

        RETURN -1;
    END IF;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_GET_PROB_AHV_CHIFFRE1 RETURN VARCHAR2

IS

BEGIN

   RETURN C_PROB_AHV_CHIFFRE1;

END;

--------------------------------------------------------------------------------

FUNCTION FC_GET_PROB_AHV_CHIFFRE2 RETURN VARCHAR2

IS

BEGIN

   RETURN C_PROB_AHV_CHIFFRE2;

END;

--------------------------------------------------------------------------------

FUNCTION FC_GET_STICHTAG_DOSSIER(p_sh_dossier_id sh_dossier.sh_dossier_id%TYPE)

RETURN sh_dossier.sh_dossier_id%TYPE IS

l_sh_dossier_id   sh_dossier.sh_dossier_id%TYPE;

BEGIN

   /*
      Fallbearbeitungsnummer:
      roh_sh_dossier.gemeinde_id
      roh_sh_dossier.sozialleistungstraeger_id
      roh_sh_dossier.sh_leistungstyp_id
      roh_sh_dossier.jahr
      roh_sh_dossier.dossiernummer
      roh_sh_dossier.b_neubezuegerrecord
   */

   SELECT sh_dossier_id
   INTO l_sh_dossier_id
   FROM sh_dossier d1,
      (
         SELECT
            d.gemeinde_id, d.sozialleistungstraeger_id,
            d.sh_leistungstyp_id, d.jahr, d.dossiernummer
         FROM sh_dossier d
         WHERE d.sh_dossier_id = p_sh_dossier_id
      ) d2
   WHERE d1.gemeinde_id = d2.gemeinde_id
   AND d1.sozialleistungstraeger_id = d2.sozialleistungstraeger_id
   AND d1.sh_leistungstyp_id = d2.sh_leistungstyp_id
   AND d1.jahr = d2.jahr
   AND d1.dossiernummer = d2.dossiernummer
   AND d1.b_neubezuegerrecord = 1
   ORDER BY DECODE(sh_dossier_id, p_sh_dossier_id, 0, 1) ASC;

   RETURN l_sh_dossier_id;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END;

--------------------------------------------------------------------------------

FUNCTION FC_GET_DOSSIER_STATUS(p_sh_dossier_id sh_dossier.sh_dossier_id%TYPE)

RETURN sh_dossier.dossier_status_id%TYPE IS

l_sh_dossier_id   sh_dossier.sh_dossier_id%TYPE := NULL;

BEGIN

   SELECT dossier_status_id
   INTO l_sh_dossier_id
   FROM sh_dossier
   WHERE sh_dossier_id = p_sh_dossier_id;

   RETURN l_sh_dossier_id;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN NULL;

END;

--------------------------------------------------------------------------------

FUNCTION FC_STAT_PRIORITY(p_status_id sh_dossier.dossier_status_id%TYPE) RETURN INTEGER DETERMINISTIC

IS

p_priority     INTEGER := NULL;

BEGIN

   CASE (p_status_id)
      WHEN 1 THEN p_priority := 1;
      WHEN 2 THEN p_priority := 2;
      WHEN 3 THEN p_priority := 3;
      WHEN 4 THEN p_priority := 4;
      WHEN 41 THEN p_priority := 4;
      WHEN 42 THEN p_priority := 4;
      WHEN 43 THEN p_priority := 4;
      WHEN 5 THEN p_priority := 5;
      ELSE BEGIN
         IF ( p_status_id IS NULL ) THEN
            p_priority := 1;
         ELSIF ( p_status_id < 0 ) THEN
            p_priority := p_status_id;
         END IF;
      END;
   END CASE;

   RETURN p_priority;

END;

--------------------------------------------------------------------------------
/* --------------------------------------------------------------------------
   ISOS 5.0
   ********
   Version 1.00   05.11.2009   Oliver Heiler, Concevis AG
   Grund:         Gültigkeit wird über die neue Tabelle fehler_test_leistungsfilter verwaltet

* -------------------------------------------------------------------------- */

FUNCTION FC_GET_FEHLER_GUELTIGKEIT(p_sh_dossier_id sh_dossier.sh_dossier_id%TYPE, p_fehler_id v_fehler_test.fehler_id%TYPE) RETURN INTEGER
IS

l_return INTEGER := NULL;

BEGIN

-- TODO Tabelle fehler_test_leistungsfilter

   /* SELECT COUNT(*)
    INTO l_return
    FROM fehler_test_gueltigkeit f, leistungsfilter_gueltigkeit l WHERE f.fehler_id = p_fehler_id
    AND f.leistungsfilter_gueltigkeit_id = l.leistungsfilter_gueltigkeit_id
    AND l.sh_leistungsfilter_id =
    (SELECT v.sh_leistungsfilter_id FROM v_sh_leistungstyp v, sh_dossier d
     WHERE d.sh_leistungstyp_id = v.sh_leistungstyp_id
     AND d.sh_dossier_id = p_sh_dossier_id); */

     SELECT COUNT(*)
    INTO l_return
    FROM fehler_test_leistungsfilter f WHERE f.fehler_id = p_fehler_id
    AND f.sh_leistungsfilter_id =
    (SELECT v.sh_leistungsfilter_id FROM v_sh_leistungstyp v, sh_dossier d
     WHERE d.sh_leistungstyp_id = v.sh_leistungstyp_id
     AND d.sh_dossier_id = p_sh_dossier_id);

     RETURN l_return;
END;


--------------------------------------------------------------------------------
/* --------------------------------------------------------------------------
   ISOS 5.0
   ********
   Version 1.00   05.11.2009   Oliver Heiler, Concevis AG
   Grund:         Gültigkeit wird über die neue Tabelle fehler_aktion_leistungsfilter verwaltet

* -------------------------------------------------------------------------- */

FUNCTION FC_GET_AKTION_GUELTIGKEIT(p_sh_dossier_id sh_dossier.sh_dossier_id%TYPE, p_akt_id v_fehler_aktion.akt_id%TYPE) RETURN INTEGER
IS

l_return INTEGER := NULL;

BEGIN
-- TODO Tabelle fehler_aktion_leistungsfilter

    /*SELECT COUNT(*)
    INTO l_return
    FROM fehler_aktion_gueltigkeit f, leistungsfilter_gueltigkeit l WHERE f.akt_id = p_akt_id
    AND f.leistungsfilter_gueltigkeit_id = l.leistungsfilter_gueltigkeit_id
    AND l.sh_leistungsfilter_id =
    (SELECT v.sh_leistungsfilter_id FROM v_sh_leistungstyp v, sh_dossier d
     WHERE d.sh_leistungstyp_id = v.sh_leistungstyp_id
     AND d.sh_dossier_id = p_sh_dossier_id);*/

     SELECT COUNT(*)
    INTO l_return
    FROM fehler_aktion_leistungsfilter f WHERE f.akt_id = p_akt_id
    AND f.sh_leistungsfilter_id =
    (SELECT v.sh_leistungsfilter_id FROM v_sh_leistungstyp v, sh_dossier d
     WHERE d.sh_leistungstyp_id = v.sh_leistungstyp_id
     AND d.sh_dossier_id = p_sh_dossier_id);

     RETURN l_return;
END;


--------------------------------------------------------------------------------

FUNCTION FC_GET_SUBMODUL_STATUS_1
  ( p_soz_traeger_datenimport_id IN INTEGER,
   p_standort_id IN INTEGER,
    p_submodul IN INTEGER)
  RETURN  VARCHAR2
IS

   retVal                 VARCHAR2(10);
   cnt                     INTEGER;

BEGIN
    retVal := '--';

    SELECT COUNT(*) INTO cnt
    FROM stdi_aktion, v_fehler_aktion
    WHERE soz_traeger_datenimport_id = p_soz_traeger_datenimport_id
    AND standort_id = p_standort_id
    AND stdi_aktion.akt_id = v_fehler_aktion.akt_id
    AND v_fehler_aktion.akt_stufe = 2
    AND submodul = p_submodul
    AND b_abbruch = 1;

    IF (cnt > 0) THEN
       retVal := 'Ja';
    ELSE
       retVal := 'Nein';
    END IF;

    RETURN retVal;
END;
--------------------------------------------------------------------------------

FUNCTION FC_GET_SUBMODUL_STATUS_2
  ( p_soz_traeger_datenimport_id IN INTEGER,
   p_standort_id IN INTEGER,
    p_submodul IN INTEGER)
  RETURN  VARCHAR2
IS

   retVal                 VARCHAR2(10);
   phase_id               INTEGER;
   stand_phase            INTEGER;

BEGIN

    SELECT DECODE(p_submodul,1,8,3,10,5,12,6,14,7,16,8,5) INTO phase_id FROM DUAL;

    SELECT aufbereitungsphase_id INTO stand_phase FROM soz_traeger_datenimport
    WHERE soz_traeger_datenimport_id = p_soz_traeger_datenimport_id
    AND standort_id = p_standort_id;


   IF stand_phase >= phase_id OR stand_phase IN (5,6) THEN
      retVal := 'Ja';
   ELSE
      retVal := 'Nein';
   END IF;

   RETURN retVal;
END;

/* --------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.00   09.10.2008   Oliver Heiler, Concevis AG
   Grund:         Mit ISOS 4.2 wird die neue Versichertennummer importiert.
                  Während des Importes, wird diese Funktion aufgerufen.
                  Die Funktion prüft die Gültigkeit der Versichertennummer
* -------------------------------------------------------------------------- */

FUNCTION FC_TEST_VERSICHERTENNUMMER (p_vers_nummer IN VARCHAR2)
RETURN INTEGER
IS

sVersichertennummer VARCHAR2(32);
iResult INTEGER;
iPos INTEGER;
iLen INTEGER;
iProduct INTEGER;
iEvenSum INTEGER;
iOddSum INTEGER;
iSum INTEGER;
iDiff INTEGER;

BEGIN
iResult := 0;

sVersichertennummer := p_vers_nummer;
sVersichertennummer := REPLACE(sVersichertennummer,'.','');

iLen := LENGTH(sVersichertennummer);

IF iLen = 13 THEN
BEGIN
  IF(SUBSTR(sVersichertennummer, 1, 3) <> '756')
  THEN
  BEGIN
      iResult := 0;
      RETURN iResult;
  END;
  END IF;

   -- STEP 1
  iPos := 2;
  iEvenSum := 0;

  WHILE iPos < iLen
  LOOP
   iEvenSum := iEvenSum + TO_NUMBER(SUBSTR(sVersichertennummer, iPos, 1));
   iPos := iPos + 2;
  END LOOP;

  -- STEP 2
  iProduct := iEvenSum * 3;

  -- STEP 3
  iPos := 1;
  iOddSum := 0;

  WHILE iPos < iLen
  LOOP
   iOddSum := iOddSum + TO_NUMBER(SUBSTR(sVersichertennummer, iPos, 1));
   iPos := iPos + 2;
  END LOOP;

  -- STEP 4
  iSum := iProduct + iOddSum;

  -- STEP 5
  iDiff := (10 - iSum MOD 10) MOD 10;

   -- STEP 6
  IF (TO_NUMBER(SUBSTR(sVersichertennummer, 13, 1)) = iDiff) THEN
    iResult := 1;
  END IF;
END;
ELSE
   iResult := 0;
END IF;

RETURN iResult;

END;

/* --------------------------------------------------------------------------
   ISOS 4.2.1
   ********
   Version 1.00   02.02.2009   Oliver Heiler, Concevis AG
   Grund:         Neuer Fehlertest "Dossier vermisst"

   ISOS 4.2.1.4
   ********
   Version 1.01   27.02.2009   Oliver Heiler, Concevis AG
   Grund:         Join nur noch über AHV_NR8 statt AHV_NR8 und AHV_NR3
                  beim Vergleich mit dem Vorjahr

   ISOS 5.0.0.0
   ********
   Version 2.00   12.02.2010   Oliver Heiler, Concevis AG
   Grund:         ALBV berücksichtigen

   ISOS 6.3
   **********
   Version 3.00   30.03.2012    Änderung durch JBE, BFS
   Version 3.01   06.12.2012    SQL-Optimierung durch OH, Concevis
   Version 3.02   05.02.2013    Berücksichtigung der Leistungsgruppen, wird ein Dossier mit anderem Leistungstyp
                                als das Vorjahr geliefert, gilt es als nicht vermisst, soweit sich der neue Leistungstyp
                                in der gleichen Leistungsgruppe befindet
* -------------------------------------------------------------------------- */

FUNCTION FC_DOSSIERS_VERMISST(p_durchlauf_id IN INTEGER, p_datenimport_id IN INTEGER, p_standort_id IN INTEGER, p_jahr IN INTEGER)
RETURN INTEGER
  IS
  l_table VARCHAR(20);
  l_stmt  VARCHAR(1024);
  BEGIN
  IF p_durchlauf_id = DO_TEST_DBL.C_RUN_PROBELAUF THEN
    l_table := 'stdi_fehler_pl';
  ELSE
    l_table := 'stdi_fehler';
  END IF;
  l_stmt := ' INSERT INTO ' || l_table || ' (sh_dossier_id, soz_traeger_lieferung_id, soz_traeger_registration_id, soz_traeger_datenimport_id, standort_id, fehler_id, fehler_nr)
              VALUES (:dossid,
                  (SELECT soz_traeger_lieferung_id FROM soz_traeger_datenimport WHERE soz_traeger_datenimport_id = :p_datenimport_id AND standort_id = :p_standort_id),
                  (SELECT soz_traeger_registration_id FROM soz_traeger_datenimport WHERE soz_traeger_datenimport_id = :p_datenimport_id AND standort_id = :p_standort_id),
                  :p_datenimport_id, :p_standort_id, 2008, ''F1-9-1'')';

  FOR x IN (

SELECT DISTINCT t_alias.sh_dossier_id AS dossid,
                t_alias.soz_traeger_lieferung_id AS lieferid,
                t_alias.soz_traeger_registration_id AS regid
FROM (
     SELECT /*+ ordered use_hash( SH_DOSSIER , ANTRAGSTELLER , t, ANTRAGSTELLER_ALBV, ue_person_albv, v_sh_zustaendigkeit ) */ dos.sh_dossier_id             AS sh_dossier_id,
             dos.sozialleistungstraeger_id AS sozid,
             ant.versichertennummer        AS vers_nr,
             dos.soz_traeger_lieferung_id,
             dos.soz_traeger_datenimport_id,
             dos.standort_id,
             dos.soz_traeger_registration_id,
             lg.sh_leistungsgruppe_id as leistungsgruppe
      FROM SH_DOSSIER dos
      INNER JOIN v_sh_zustaendigkeit t                  ON (t.sozialleistungstraeger_id = dos.sozialleistungstraeger_id
                                                          AND t.gemeinde_id = dos.gemeinde_id
                                                          AND t.sh_leistungstyp_id = dos.sh_leistungstyp_id)
      INNER JOIN ANTRAGSTELLER ant                    ON (dos.sh_dossier_id = ant.sh_dossier_id)
      INNER JOIN leistungsgruppe_typ lg ON (dos.sh_leistungstyp_id = lg.sh_leistungstyp_id)
      INNER JOIN v_sh_leistungsgruppe vlg ON (vlg.sh_leistungsgruppe_id = lg.sh_leistungsgruppe_id)
      LEFT OUTER JOIN ANTRAGSTELLER_ALBV albv_ant     ON (albv_ant.sh_dossier_id = dos.sh_dossier_id)
      LEFT OUTER JOIN ue_person_albv albv_ue ON (albv_ue.sh_dossier_id = dos.sh_dossier_id)
      WHERE dos.jahr = p_jahr - 1
        AND dos.soz_traeger_lieferung_id = (
                                            SELECT soz_traeger_lieferung_id
                                            FROM SOZ_TRAEGER_LIEFERUNG
                                            WHERE sozialleistungstraeger_id = (
                                                                               SELECT sozialleistungstraeger_id
                                                                               FROM SOZ_TRAEGER_LIEFERUNG,
                                                                                    SOZ_TRAEGER_DATENIMPORT
                                                                               WHERE SOZ_TRAEGER_DATENIMPORT.soz_traeger_datenimport_id = p_datenimport_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.standort_id = p_standort_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.soz_traeger_lieferung_id = SOZ_TRAEGER_LIEFERUNG.soz_traeger_lieferung_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.standort_id = SOZ_TRAEGER_LIEFERUNG.standort_id
                                                                              )
                                            AND jahr = p_jahr - 1
                                           )
        AND dos.standort_id = p_standort_id
        AND to_number(to_char(t.dat_von, 'YYYY')) <= p_jahr
        AND to_number(to_char(t.dat_bis, 'YYYY')) >= p_jahr
        AND dos.sh_leistungstyp_id IN (1,2,3,4,5,21,22,23,25,26,32,33,34,35,36,37)
        AND dos.b_neubezuegerrecord = 1
        AND ant.versichertennummer NOT LIKE '%-%'
        AND dos.dossier_status_id <> 5
        AND (((dos.sh_leistungstyp_id = 25 AND ((albv_ant.b_bezug_stichtag = 1 OR albv_ue.b_bezug_stichtag = 1)
               AND (EXTRACT(YEAR FROM albv_ant.dat_letzte_zahlung) = 9999 OR EXTRACT(YEAR FROM albv_ue.dat_letzte_zahlung) = 9999)))
              OR
              (dos.sh_leistungstyp_id <> 25 AND ((dos.b_bezug_stichtag = 1) AND (EXTRACT(YEAR FROM dos.dat_letzte_zahlung) = 9999))))
             OR
             ((dos.sh_leistungstyp_id <> 25 AND (dos.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY')))
              OR (dos.sh_leistungstyp_id = 25 AND ((albv_ant.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY'))
                OR (albv_ue.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY'))))))
     ) t_alias
WHERE NOT EXISTS (
                  SELECT 1
                  FROM ROH_SH_DOSSIER dos
                  INNER JOIN ROH_ANTRAGSTELLER ant ON (dos.sh_dossier_id = ant.sh_dossier_id)
                  INNER JOIN leistungsgruppe_typ lg ON (dos.sh_leistungstyp_id = lg.sh_leistungstyp_id)
                  INNER JOIN v_sh_leistungsgruppe vlg ON (vlg.sh_leistungsgruppe_id = lg.sh_leistungsgruppe_id)
                  WHERE dos.jahr = p_jahr
                    AND dos.soz_traeger_datenimport_id = p_datenimport_id
                    AND dos.standort_id = p_standort_id
                    AND t_alias.leistungsgruppe = lg.sh_leistungsgruppe_id
                    AND dos.b_neubezuegerrecord = 1
                    AND t_alias.sozid = dos.sozialleistungstraeger_id
                    AND (
                         t_alias.vers_nr = ant.versichertennummer
                         AND t_alias.vers_nr NOT LIKE '%-%'
                         AND ant.versichertennummer NOT LIKE '%-%'
                        )
                 )
  )
  LOOP
            EXECUTE IMMEDIATE l_stmt USING x.dossid, p_datenimport_id, p_standort_id, p_datenimport_id, p_standort_id, p_datenimport_id, p_standort_id;

  END LOOP;
  RETURN 0;
  END;

/*FUNCTION FC_DOSSIERS_VERMISST(p_durchlauf_id IN INTEGER, p_datenimport_id IN INTEGER, p_standort_id IN INTEGER, p_jahr IN INTEGER)
RETURN INTEGER
  IS
  l_table VARCHAR(20);
  l_stmt  VARCHAR(1024);
  BEGIN
  IF p_durchlauf_id = DO_TEST_DBL.C_RUN_PROBELAUF THEN
    l_table := 'stdi_fehler_pl';
  ELSE
    l_table := 'stdi_fehler';
  END IF;
  l_stmt := ' INSERT INTO ' || l_table || ' (sh_dossier_id, soz_traeger_lieferung_id, soz_traeger_registration_id, soz_traeger_datenimport_id, standort_id, fehler_id, fehler_nr)
              VALUES (:dossid,
                  (SELECT soz_traeger_lieferung_id FROM soz_traeger_datenimport WHERE soz_traeger_datenimport_id = :p_datenimport_id AND standort_id = :p_standort_id),
                  (SELECT soz_traeger_registration_id FROM soz_traeger_datenimport WHERE soz_traeger_datenimport_id = :p_datenimport_id AND standort_id = :p_standort_id),
                  :p_datenimport_id, :p_standort_id, 2008, ''F1-9-1'')';

  FOR x IN (
  SELECT DISTINCT t_alias.sh_dossier_id as dossid, t_alias.soz_traeger_lieferung_id as lieferid,
                  t_alias.soz_traeger_registration_id as regid FROM ( SELECT dos.sh_dossier_id as sh_dossier_id, dos.sozialleistungstraeger_id as sozid,
             ant.ahv_nr8 AS ahv_nr8, ant.versichertennummer as vers_nr, dos.dossiernummer as dos_nr,
             dos.soz_traeger_lieferung_id, dos.soz_traeger_datenimport_id, dos.standort_id, dos.soz_traeger_registration_id
             FROM sh_dossier dos
             INNER JOIN antragsteller ant ON (dos.sh_dossier_id = ant.sh_dossier_id)
             INNER JOIN v_sh_zustaendigkeit t ON (t.sozialleistungstraeger_id = dos.sozialleistungstraeger_id AND t.gemeinde_id = dos.gemeinde_id AND t.sh_leistungstyp_id = dos.sh_leistungstyp_id )
             LEFT OUTER JOIN antragsteller_albv albv_ant ON (albv_ant.sh_dossier_id = dos.sh_dossier_id)
             LEFT OUTER JOIN ue_person_albv albv_ue ON (albv_ue.sh_dossier_id = dos.sh_dossier_id)
             WHERE dos.jahr = p_jahr-1
                AND dos.soz_traeger_lieferung_id =
                  (SELECT soz_traeger_lieferung_id FROM soz_traeger_lieferung WHERE sozialleistungstraeger_id =
                    (SELECT sozialleistungstraeger_id FROM soz_traeger_lieferung, soz_traeger_datenimport
                     WHERE soz_traeger_datenimport.soz_traeger_datenimport_id = p_datenimport_id
                     AND soz_traeger_datenimport.standort_id = p_standort_id
                     AND soz_traeger_datenimport.soz_traeger_lieferung_id = soz_traeger_lieferung.soz_traeger_lieferung_id
                     AND soz_traeger_datenimport.standort_id = soz_traeger_lieferung.standort_id) and jahr = p_jahr-1)
                   AND dos.standort_id = p_standort_id
             AND to_number(to_char(t.dat_von, 'YYYY')) <= p_jahr AND to_number(to_char(t.dat_bis, 'YYYY')) >= p_jahr
             AND dos.sh_leistungstyp_id IN
                    ( SELECT DISTINCT sh_leistungstyp_id FROM leistungsgruppe_typ WHERE sh_leistungsgruppe_id IN (1,2,5,6,7,8))
             AND dos.b_neubezuegerrecord = 1
             AND (
                    ( (dos.b_bezug_stichtag = 1 OR albv_ant.b_bezug_stichtag = 1 OR albv_ue.b_bezug_stichtag = 1) AND
                       (
                         (
                            EXTRACT(YEAR FROM dos.dat_letzte_zahlung) = 9999
                            OR EXTRACT(YEAR FROM albv_ant.dat_letzte_zahlung) = 9999
                            OR EXTRACT(YEAR FROM albv_ue.dat_letzte_zahlung) = 9999
                         )
                       )  --ajout STG
                       OR
                         (
                            dos.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY')
                            OR
                            albv_ant.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY')
                            OR
                            albv_ue.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(p_jahr-1),'DD.MM.YYYY')
                         )
                    )
  --   ) enlevé STG
                    AND
                     (
                        ( ant.ahv_nr8 <> '-3' AND ant.ahv_nr8 <> '163;28;17;236;153;30;246;224;218;143;53;142;183;26;49;120;219;97;119;176;134;145;122;120;13;230;243;143;68;250;196;68')
                          OR (ant.versichertennummer NOT IN('-3','-1', '-12', '-13', '-9'))
                     )
                  )
             AND dos.dossier_status_id <> 5
            ) t_alias
             LEFT OUTER JOIN ( SELECT dos.sh_dossier_id, dos.sozialleistungstraeger_id as sozid, ant.ahv_nr8 AS ahv_nr8,
                                ant.versichertennummer as vers_nr, dos.dossiernummer as dos_nr,
                                dos.soz_traeger_datenimport_id, dos.standort_id
                         FROM roh_sh_dossier dos
                             INNER JOIN roh_antragsteller ant ON (dos.sh_dossier_id = ant.sh_dossier_id)
                         WHERE dos.jahr = p_jahr
                         AND dos.soz_traeger_datenimport_id = p_datenimport_id AND dos.standort_id = p_standort_id
                         AND dos.sh_leistungstyp_id IN
                        ( SELECT DISTINCT sh_leistungstyp_id FROM leistungsgruppe_typ WHERE sh_leistungsgruppe_id IN (1,2,5,6,7,8))
                        AND dos.b_neubezuegerrecord = 1
            ) currentEp
            ON (
                    (
                        (
                          t_alias.ahv_nr8 = currentEp.ahv_nr8) AND (t_alias.ahv_nr8 <> '-3' AND t_alias.ahv_nr8 <> '163;28;17;236;153;30;246;224;218;143;53;142;183;26;49;120;219;97;119;176;134;145;122;120;13;230;243;143;68;250;196;68')
                        OR
                        (
                          t_alias.vers_nr = currentEp.vers_nr AND t_alias.vers_nr NOT IN('-3','-1', '-12', '-13', '-9')
                        )
                        OR t_alias.dos_nr = currentEp.dos_nr
                    )
                    AND t_alias.sozid = currentEp.sozid
               )
            WHERE  ( currentEp.sh_dossier_id IS NULL  )
            AND  DO_TEST.FC_GET_DOSSIER_STATUS(t_alias.sh_dossier_id) <> 5
            AND  DO_TEST.FC_GET_FEHLER_GUELTIGKEIT(t_alias.sh_dossier_id, 2008) > 0
  )
  LOOP
            EXECUTE IMMEDIATE l_stmt USING x.dossid, p_datenimport_id, p_standort_id, p_datenimport_id, p_standort_id, p_datenimport_id, p_standort_id;

  END LOOP;
  RETURN 0;
  END;
*/

PROCEDURE SP_UPD_LIEFERUNG_IMPORT_DATUM ( p_soz_traeger_lieferung_id soz_traeger_lieferung.soz_traeger_lieferung_id%TYPE, p_standort_id soz_traeger_lieferung.standort_id%TYPE )
IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN

   UPDATE soz_traeger_lieferung
   SET dat_erster_import = (SELECT min(import_datum) FROM soz_traeger_datenimport  WHERE soz_traeger_lieferung_id = p_soz_traeger_lieferung_id AND standort_id = p_standort_id),
   dat_letzter_import = ( SELECT max(import_datum) FROM soz_traeger_datenimport  WHERE soz_traeger_lieferung_id = p_soz_traeger_lieferung_id AND standort_id = p_standort_id)
   WHERE soz_traeger_lieferung_id = p_soz_traeger_lieferung_id AND standort_id = p_standort_id;
   COMMIT;
END;




---- Fonction qui détecte les dossiers equivalents manquants sous l'état stichtag (SM5), JBE 15.12.2011
FUNCTION FC_MANK_STICHTAG(p_sh_dossier_id INTEGER) RETURN VARCHAR2

IS

djoul VARCHAR2(1024) := NULL;

BEGIN

   SELECT TO_CHAR(a.dat_geburt, 'DD.MM.YYYY') || '#'
      || TO_CHAR(a.geschlecht_id) || '#'
      || TO_CHAR(a.versichertennummer)  || '#'
      || TO_CHAR(d.gemeinde_id) || '#'
      || TO_CHAR(DECODE(d.sh_leistungstyp_id, 1, 99, 2, 99, 3, 99, 4, 99, 5, 99, d.sh_leistungstyp_id))  || '#'
      || TO_CHAR(d.jahr) || '#'
      || TO_CHAR(d.dat_erste_auszahlung, 'DD.MM.YYYY')
   INTO djoul
   FROM roh_antragsteller a,
        roh_sh_dossier d
   WHERE a.sh_dossier_id = d.sh_dossier_id
   AND a.sh_dossier_id = p_sh_dossier_id
   AND FC_MISSING(a.dat_geburt) = 0
   AND FC_MISSING(a.geschlecht_id) = 0
   AND FC_MISSING(d.gemeinde_id) = 0
   AND FC_MISSING(d.sh_leistungstyp_id) = 0
   AND FC_MISSING(d.jahr)= 0
   AND FC_MISSING(d.dat_erste_auszahlung) = 0
   AND EXTRACT (YEAR FROM d.dat_erste_auszahlung) = d.jahr
   AND SUBSTR(a.versichertennummer,1,1) <> '-';

   RETURN djoul;

EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN NULL;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_IS_ALBV_KANTON(p_sozialleistungstraeger IN VARCHAR2) RETURN INTEGER
IS
    iKanton INTEGER;
    bAlbvKanton INTEGER;
    sSTlong VARCHAR2(12);

BEGIN
    sSTlong := '000000' || p_sozialleistungstraeger;
    iKanton := TO_NUMBER(SUBSTR(SUBSTR(sSTlong, -6,6),1,2));

    IF iKanton IN (9,10,22,23,24,25,26) THEN
         bAlbvKanton := 1;
    ELSE
        bAlbvKanton := 0;
    END IF;

    RETURN bAlbvKanton;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_IS_6_MT_BETWEEN(pFromDate IN DATE, pToDate IN DATE) RETURN INTEGER
IS
    iResult INTEGER;
    fm INTEGER;
    tm INTEGER;
    fy INTEGER;
    ty INTEGER;
    diffMt INTEGER;
BEGIN
    iResult := 0;

    IF  pFromDate IS NOT NULL
        AND pToDate IS NOT NULL
        AND pFromDate < TO_DATE('01.01.9998', 'DD.MM.YYYY') AND pToDate < TO_DATE('01.01.9998', 'DD.MM.YYYY') THEN
    BEGIN
        fy := EXTRACT ( YEAR FROM pFromDate);
        ty := EXTRACT ( YEAR FROM pToDate);
        fm := EXTRACT ( MONTH FROM pFromDate);
        tm := EXTRACT ( MONTH FROM pToDate);
        diffMt := (12*ty + tm) - (12*fy + fm);

        IF diffMt = 6 THEN
            iResult := 0;
        ELSE
            iResult := 1;
        END IF;
    END;
    END IF;

    RETURN iResult;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */
FUNCTION FC_BFS_CODE(p_plz_id VARCHAR2) RETURN INTEGER
IS
    bfs_code INTEGER;
    l_count INTEGER;

BEGIN
    l_count := 0;

    IF  LENGTH(p_plz_id) = 8 THEN
        BEGIN
            SELECT COUNT(1) INTO l_count FROM v_plz_neu WHERE  plz_id = p_plz_id;
            IF l_count > 0 THEN
                SELECT gemeinde_id INTO bfs_code FROM v_plz_neu WHERE plz_id = p_plz_id;
            END IF;
        END;
    ELSE
        bfs_code := CASE WHEN FC_ISNUMERIC(p_plz_id) THEN TO_NUMBER(p_plz_id) ELSE NULL END;
    END IF;

    RETURN bfs_code;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   15.04.2013   Oliver Heiler, Concevis AG
   Grund:         Harmonisierung Plausex und ISOS Funktion wird für die Plausibilisierung benötigt

* -------------------------------------------------------------------------- */

FUNCTION FC_ISNUMERIC (param VARCHAR2) RETURN BOOLEAN
IS
   dummy number;
BEGIN
   dummy:=to_number(param);
   RETURN true;
EXCEPTION
   WHEN OTHERS THEN
       RETURN false;
END;


END;
/

create or replace 
PACKAGE BODY        "DO_PLAUSI" IS
/* --------------------------------------------------------------------------

    ISOS 6.4
    ***********
    Version 1.1  26.04.2013 Oliver Heiler, Dietmar Kaspers, Concevis AG
    SP_PLAUSIS_EX eingefügt.

* -------------------------------------------------------------------------- */


/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   SP_PLAUSIS_EX
   Version 1.0   26.04.2013   Oliver Heiler, Dietmar Kaspers, Concevis AG
   Harmonisierung zwischen ISOS und Plausex Plausiblisierung.
   Die Flags in v_plausi b_aktiv_plausex, b_aktiv_isos steuern steuern den Gültigkeitsbereich
   b_aktiv_plausex = 1, b_aktiv_isos = 1 =>   Tabelle v_plausi enthält analog zu Plausex inhaltlich die gleichen Regeln (nur syntaktische Anpassung zw. Oracle und SQL-Server)
   b_aktiv_isos = 1, b_aktiv_plausex = 0 =>   Spezifische Regeln in ISOS z.B Dossierübergreifende Prüfung Dossier vermisst oder Dubletten
   b_atkiv_isos = 0 , b_aktiv_plausex = 1 =>  Spezifische Regeln in Plausex, Prüfung der Dossier-Adresse oder Regeln mit Prüfung Versichertennummer > 0 (chiffriert in ISOS)
  
   Version 1.1   22.08.2013   Oliver Heiler, Concevis AG
   Neue Parameter p_data_context = 1 für die Unterscheidung zwischen Primär- und Sekundärdaten
   Beispiel: 
   Der Dublettentest wird auch von der Imputation (Sekundärdaten) aufgerufen. Nur dort werden notwendige Updates durchgeführt und die Imputationstabelle befüllt
   Während der Plausibilisierung (Primärdaten) werden nur die notwendige Dossier Stati gesetzt und die Plausitabelle befüllt
   Parameterwert p_data_context = 1 => Primärdaten
   Parameterwert p_data_context = 2 => Sekundärdaten
   
   
* -------------------------------------------------------------------------- */


   PROCEDURE SP_PLAUSIS_EX ( p_datenimport_id INTEGER, p_standort_id INTEGER, p_data_context INTEGER, p_debug_option INTEGER)
   IS
 
 
  
            
   l_selektion_id          selektion.selektion_id%TYPE := NULL;
   debug_option            INTEGER;
   l_plausi_statement      VARCHAR2(4000);
   param1                  INTEGER;
   param2                  INTEGER;
   param3                  INTEGER;
   l_result                INTEGER;
   l_erhebungsjahr         INTEGER;
    
   BEGIN
   
   IF (p_data_context NOT IN (1,2)) THEN
        raise_application_error(-20000, 'Fehler in Prozedur SP_PLAUSIS_EX aufgetreten. Ungültiger Parameter p_data_context. Der Wert muss 1 oder 2 sein. ' || sqlerrm);
        -- added SQLERRM to find errors.
   END IF;
       
   l_result := 0;
   
   IF p_debug_option = 1 THEN
        DELETE dbg_test_plausi;
        COMMIT;
   END IF;

   SELECT SELEKTION_SEQUENZ.NEXTVAL
   INTO l_selektion_id
   FROM DUAL;

   DO_SPEZIALCODES_PKG.SP_INSERT_INTO_IMPORT_SEL(l_selektion_id, p_datenimport_id, p_standort_id);

   DELETE FROM sh_dossier_plausi WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id;
   
   SELECT jahr INTO l_erhebungsjahr 
   FROM soz_traeger_lieferung
   INNER JOIN soz_traeger_datenimport
   ON ( soz_traeger_datenimport.soz_traeger_lieferung_id = soz_traeger_lieferung.soz_traeger_lieferung_id AND 
        soz_traeger_datenimport.standort_id = soz_traeger_lieferung.standort_id)
   WHERE soz_traeger_datenimport.soz_traeger_datenimport_id = p_datenimport_id AND soz_traeger_datenimport.standort_id = p_standort_id;
   
   FOR x IN (

      SELECT DISTINCT pm.plausimeldung_id, p.leistungsfilter, p.kanton_id, p.from_bedingung, p.where_bedingung, p.and_bedingung, p.proc, pm.param1, pm.param2, pm.param3, p.plausi_id
      FROM v_plausi p
      INNER JOIN v_plausimeldung pm ON pm.plausi_id = p.plausi_id
      INNER JOIN (
               SELECT DISTINCT i.leistungsfilter_id, i.kanton_id
               FROM import_selektion i
               WHERE i.selektion_id = l_selektion_id

      ) s ON ',' || REPLACE(p.leistungsfilter, ' ', '') || ',' LIKE '%,' || s.leistungsfilter_id || ',%'
      WHERE (p.kanton_id is null OR TO_CHAR(s.kanton_id) IN p.kanton_id)
      AND p.b_aktiv_isos = 1
      ORDER BY pm.plausimeldung_id

   ) LOOP

     IF x.proc is not NULL THEN
     BEGIN

       l_plausi_statement :=  'BEGIN ' || x.proc || ' (:sel_id, :result, :datenimport_id, :standort_id, :data_context); END;';
        
        IF p_debug_option = 1 THEN
            INSERT INTO dbg_test_plausi (plausimeldung_id, sql_statement) VALUES (x.plausimeldung_id, l_plausi_statement);
        COMMIT;
        END IF;
        
       EXECUTE IMMEDIATE l_plausi_statement USING IN l_selektion_id, OUT l_result, IN p_datenimport_id, IN p_standort_id, IN p_data_context;
      
       IF (l_result < 0) THEN
        raise_application_error(-20000, 'Fehler in Prozedur ' || x.proc || ' aufgetreten.'||sqlerrm);
        -- added SQLERRM to find errors.
       END IF;
        
     END;
     ELSE
     
/*------------------------------------------------------------------------------

*** BFS comments

** Modification 30.07.2013 : 
     
Added "DISTINCT" to the "s.dossier" SELECT in the FROM clause of the INSERT 
statement construction below. Since we want to make the INSERT in SH_DOSSIER_PLAUSI, the 
combination of "dossier_id" and "plausimeldung_id" must be unique. 

**  Modification 05.08.2013 :

Following the propositions of release note chap. 3 for ISOS v. 6.4, we added a column
in the "x" cursor : p.plausi_id.

This addition comes for another modification at the top end of the INSERT statement below :
"AND (sh_dossier.b_neubezuegerrecord = 1 OR '|| x.plausi_id || 'in (200050))".

Plausi_id n°200050 = <Aafs-02>.


** Modification 14.10.2013

Added parenthesis around WHERE clause. 

 
  
------------------------------------------------------------------------------*/
     
     BEGIN
        l_plausi_statement := 'INSERT INTO sh_dossier_plausi (plausimeldung_id, sh_dossier_id, soz_traeger_datenimport_id, standort_id) ' ||
            'SELECT ' || x.plausimeldung_id || ', t.dossier_id ' || ',' || p_datenimport_id || ',' || p_standort_id ||
            ' FROM ' ||
            '( ' ||
            '   SELECT DISTINCT(s.dossier_id) ' ||
            '   FROM ' || REPLACE(REPLACE(REPLACE(x.from_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr)  || ' INNER JOIN import_selektion s ON (sh_dossier.sh_dossier_id = s.dossier_id) ' ||
            '   WHERE (' || REPLACE(REPLACE(REPLACE(x.where_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr) || 
            ') ' || NVL(REPLACE(REPLACE(REPLACE(x.and_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr), '') ||
            '   AND sh_dossier.sh_leistungstyp_id IN ( SELECT sh_leistungstyp_id FROM v_sh_leistungstyp WHERE sh_leistungsfilter_id = s.leistungsfilter_id) ' ||
            '   AND s.selektion_id = ' || l_selektion_id ||
            '   AND '',' || REPLACE(x.leistungsfilter, ' ', '') || ','' LIKE ''%,'' || s.leistungsfilter_id || '',%''' ||
                CASE WHEN x.kanton_id is not null THEN ' s.kanton_id IN (' || x.kanton_id || ')' ELSE '' END ||
            '   AND (sh_dossier.b_neubezuegerrecord = 1 OR '|| x.plausi_id || ' in (200050)) )t ';

  
        IF p_debug_option = 1 THEN
            INSERT INTO dbg_test_plausi (plausimeldung_id, sql_statement) VALUES (x.plausimeldung_id, l_plausi_statement);
        COMMIT;
        END IF;

        IF x.param1 IS NULL THEN
          EXECUTE IMMEDIATE l_plausi_statement;
        ELSE
          IF x.param2 IS NULL THEN
            EXECUTE IMMEDIATE l_plausi_statement USING x.param1;
          ELSE
            IF x.param3 IS NULL THEN
              EXECUTE IMMEDIATE l_plausi_statement USING x.param1, x.param2;
            ELSE
              EXECUTE IMMEDIATE l_plausi_statement USING x.param1, x.param2, x.param3;
            END IF;
          END IF;
        END IF;
     END;
     END IF;

   END LOOP;

   DELETE FROM
      import_selektion
   WHERE
      selektion_id = l_selektion_id;
      
      
    EXCEPTION
      WHEN OTHERS THEN
      DELETE FROM IMPORT_SELEKTION
      WHERE selektion_id = l_selektion_id;
      COMMIT;
      RAISE;
     
   --COMMIT;

   END;

   PROCEDURE SET_ROH_SH_DOSSIER(dossier_id IN INTEGER)

   IS

   b_problem         INTEGER;

   BEGIN

      SELECT DECODE(COUNT(*), 0, 0, 1) INTO b_problem
      FROM roh_sh_dossier_plausi
      WHERE sh_dossier_id = dossier_id
      AND b_bearbeitet = 0;

      UPDATE roh_sh_dossier
      SET b_plausiproblem = b_problem
      WHERE sh_dossier_id = dossier_id;
   END;

        FUNCTION F_ATTR_INTEGER_IS_UNKNOWN ( attr IN integer)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           if (attr In (-1,-3)) Then
        return 1;
       Else
        return 0;
       End if;
        END;

        FUNCTION F_ATTR_DATE_IS_UNKNOWN ( attr IN Date)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           Return 0;
        END;

        FUNCTION F_ATTR_VARCHAR_IS_UNKNOWN ( attr IN Varchar2)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           if attr In ('-1','-3') Then
                Return 1;
            Else
                Return 0;
            End if;
        END;




        FUNCTION F_ATTR_INTEGER_IS_MISSING ( attr IN integer)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           if (attr In (-1,-3,-9)) Then
        return 1;
       Else
        return 0;
       End if;
        END;

        FUNCTION F_ATTR_DATE_IS_MISSING ( attr IN Date)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           Return 0;
        END;

        FUNCTION F_ATTR_VARCHAR_IS_MISSING ( attr IN Varchar2)
          RETURN integer IS
        --
        -- Purpose: Briefly explain the functionality of the function
        --
        -- MODIFICATION HISTORY
        -- Person      Date    Comments
        -- ---------   ------  -------------------------------------------
           -- Declare program variables as shown above
        BEGIN
           if attr In ('-1','-3','-9') Then
                Return 1;
            Else
                Return 0;
            End if;
        END;

 /* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   14.05.2013   Oliver Heiler, Concevis AG
   Grund:         Ersetzt Fehlertest F1-9-1, neues Plausikonzept
                  => Erzeugt Aval-05
   Version 1.01   10.09.2013   Oliver Heiler, Concevis AG
                  Anpassung SP_DOSSIERS_VERMISST kopierte Flustat-Dossiers ausschliessen => sh_dossier.sh_flustat_id is null
* -------------------------------------------------------------------------- */


PROCEDURE SP_DOSSIERS_VERMISST(p_selektion_id IN INTEGER, p_result OUT INTEGER, p_datenimport_id IN INTEGER, p_standort_id IN INTEGER, p_data_context IN INTEGER)
  IS
  l_table VARCHAR(20);
  l_stmt  VARCHAR(1024);
  l_plausi_nr v_plausi.alpha_code%TYPE;
  l_plausimeldung_id v_plausimeldung.plausimeldung_id%TYPE;
  l_jahr INTEGER;
  
  BEGIN
 
  l_plausi_nr := 'Aval-05';
  
  l_stmt := 
    ' INSERT INTO sh_dossier_plausi (
      sh_dossier_id, plausimeldung_id, soz_traeger_datenimport_id, standort_id)
      SELECT
      :dossid,
      :plausimeldung_id,
      :soz_traeger_datenimport_id,
      :standort_id
   FROM sh_dossier d
   WHERE d.sh_dossier_id = :dossid';
  
  BEGIN
     
     SELECT DISTINCT pm.plausimeldung_id
     INTO l_plausimeldung_id 
     FROM v_plausi p
     INNER JOIN v_plausimeldung pm ON (pm.plausi_id = p.plausi_id)
     WHERE p.alpha_code = l_plausi_nr;
     
     EXCEPTION
        WHEN NO_DATA_FOUND THEN
            BEGIN
              RAISE_APPLICATION_ERROR(-20001, 'Es gibt keine Plausi-Regel mit der Nummer ' || l_plausi_nr);
              p_result := -1;
            END;
  END;
        
 -- SELECT DISTINCT jahr INTO l_jahr FROM sh_dossier
  --WHERE sh_dossier_id IN ( SELECT dossier_id FROM import_selektion WHERE selektion_id = p_selektion_id);
  
  SELECT jahr INTO l_jahr 
  FROM soz_traeger_lieferung
  INNER JOIN soz_traeger_datenimport
    ON ( soz_traeger_datenimport.soz_traeger_lieferung_id = soz_traeger_lieferung.soz_traeger_lieferung_id AND 
         soz_traeger_datenimport.standort_id = soz_traeger_lieferung.standort_id)
  WHERE soz_traeger_datenimport.soz_traeger_datenimport_id = p_datenimport_id AND  soz_traeger_datenimport.standort_id = p_standort_id;
  
  FOR x IN (

SELECT DISTINCT t_alias.sh_dossier_id AS dossid,
                t_alias.soz_traeger_lieferung_id AS lieferid,
                t_alias.soz_traeger_registration_id AS regid
FROM (
     SELECT /*+ ordered use_hash( SH_DOSSIER , ANTRAGSTELLER , t, ANTRAGSTELLER_ALBV, ue_person_albv, V_SH_ZUSTAENDIGKEIT ) */ dos.sh_dossier_id             AS sh_dossier_id,
             dos.sozialleistungstraeger_id AS sozid,
             ant.versichertennummer        AS vers_nr,
             dos.soz_traeger_lieferung_id,
             dos.soz_traeger_datenimport_id,
             dos.standort_id,
             dos.soz_traeger_registration_id,
             lg.sh_leistungsgruppe_id as leistungsgruppe
      FROM SH_DOSSIER dos
      INNER JOIN v_sh_zustaendigkeit t                  ON (t.sozialleistungstraeger_id = dos.sozialleistungstraeger_id
                                                          AND t.gemeinde_id = dos.gemeinde_id
                                                          AND t.sh_leistungstyp_id = dos.sh_leistungstyp_id)
      INNER JOIN ANTRAGSTELLER ant                    ON (dos.sh_dossier_id = ant.sh_dossier_id)
      INNER JOIN leistungsgruppe_typ lg ON (dos.sh_leistungstyp_id = lg.sh_leistungstyp_id)
      INNER JOIN v_sh_leistungsgruppe vlg ON (vlg.sh_leistungsgruppe_id = lg.sh_leistungsgruppe_id)
      LEFT OUTER JOIN ANTRAGSTELLER_ALBV albv_ant     ON (albv_ant.sh_dossier_id = dos.sh_dossier_id)
      LEFT OUTER JOIN ue_person_albv albv_ue ON (albv_ue.sh_dossier_id = dos.sh_dossier_id)
      WHERE dos.jahr = l_jahr - 1
        AND dos.soz_traeger_lieferung_id = (
                                            SELECT soz_traeger_lieferung_id
                                            FROM SOZ_TRAEGER_LIEFERUNG
                                            WHERE sozialleistungstraeger_id = (
                                                                               SELECT sozialleistungstraeger_id
                                                                               FROM SOZ_TRAEGER_LIEFERUNG,
                                                                                    SOZ_TRAEGER_DATENIMPORT
                                                                               WHERE SOZ_TRAEGER_DATENIMPORT.soz_traeger_datenimport_id = p_datenimport_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.standort_id = p_standort_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.soz_traeger_lieferung_id = SOZ_TRAEGER_LIEFERUNG.soz_traeger_lieferung_id
                                                                                 AND SOZ_TRAEGER_DATENIMPORT.standort_id = SOZ_TRAEGER_LIEFERUNG.standort_id
                                                                              )
                                            AND jahr = l_jahr - 1
                                           )
        AND dos.standort_id = p_standort_id
        AND to_number(to_char(t.dat_von, 'YYYY')) <= l_jahr
        AND to_number(to_char(t.dat_bis, 'YYYY')) >= l_jahr
        AND dos.sh_leistungstyp_id IN (1,2,3,4,5,21,22,23,25,26,32,33,34,35,36,37)
        AND dos.b_neubezuegerrecord = 1
        AND ant.versichertennummer NOT LIKE '%-%'
        AND dos.dossier_status_id <> 5
        AND (((dos.sh_leistungstyp_id = 25 AND ((albv_ant.b_bezug_stichtag = 1 OR albv_ue.b_bezug_stichtag = 1)
               AND (EXTRACT(YEAR FROM albv_ant.dat_letzte_zahlung) = 9999 OR EXTRACT(YEAR FROM albv_ue.dat_letzte_zahlung) = 9999)))
              OR
              (dos.sh_leistungstyp_id <> 25 AND ((dos.b_bezug_stichtag = 1) AND (EXTRACT(YEAR FROM dos.dat_letzte_zahlung) = 9999))))
             OR
             ((dos.sh_leistungstyp_id <> 25 AND (dos.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY')))
              OR (dos.sh_leistungstyp_id = 25 AND ((albv_ant.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY'))
                OR (albv_ue.dat_letzte_zahlung BETWEEN TO_DATE('01.07.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY') AND TO_DATE('31.12.' || TO_CHAR(l_jahr-1),'DD.MM.YYYY'))))))
     ) t_alias
WHERE NOT EXISTS (
                  SELECT 1
                  FROM ROH_SH_DOSSIER dos
                  INNER JOIN ROH_ANTRAGSTELLER ant ON (dos.sh_dossier_id = ant.sh_dossier_id)
                  INNER JOIN leistungsgruppe_typ lg ON (dos.sh_leistungstyp_id = lg.sh_leistungstyp_id)
                  INNER JOIN v_sh_leistungsgruppe vlg ON (vlg.sh_leistungsgruppe_id = lg.sh_leistungsgruppe_id)
                  WHERE dos.jahr = l_jahr
                    AND dos.soz_traeger_datenimport_id = p_datenimport_id
                    AND dos.standort_id = p_standort_id
                    AND t_alias.leistungsgruppe = lg.sh_leistungsgruppe_id
                    AND dos.b_neubezuegerrecord = 1
                    AND t_alias.sozid = dos.sozialleistungstraeger_id
                    AND (
                         t_alias.vers_nr = ant.versichertennummer
                         AND t_alias.vers_nr NOT LIKE '%-%'
                         AND ant.versichertennummer NOT LIKE '%-%'
                        )
                 )
  )
  LOOP
            EXECUTE IMMEDIATE l_stmt USING x.dossid, l_plausimeldung_id, p_datenimport_id, p_standort_id, x.dossid;

  END LOOP;
  
  p_result := 0;
  
   EXCEPTION
        WHEN OTHERS THEN
            BEGIN
              p_result := -1;
              
            END;
  END;
  
  /* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   08.05.2013   Oliver Heiler, Concevis AG
   Grund:         Ersetzt Fehlertest F6-1-11, neues Plausikonzept
                  => Erzeugt Afinasi-30
   Version 2.00   27.11.2013  Oliver Heiler, Concevis AG
   Grund:         Ist nun eine Imputationsregel und basiert nun auf den Sekundärdaten
* -------------------------------------------------------------------------- */
PROCEDURE SP_FLUSTAT_COPY_CHECK(p_selektion_id IN INTEGER, p_result OUT INTEGER, p_datenimport_id IN INTEGER, p_standort_id IN INTEGER, p_data_context IN INTEGER)
IS

l_count INTEGER;
l_plausimeldung_id INTEGER;
l_plausi_nr v_plausi.alpha_code%TYPE;
l_sql_stmt VARCHAR2(1024);
l_update_stmt VARCHAR2(256);
l_update_reihenfolge INTEGER;
l_alter_wert VARCHAR2(3);
l_dummy INTEGER;

BEGIN

 l_plausi_nr := 'Afinasi-30';

 l_sql_stmt :=
   'INSERT INTO sh_dossier_imputation (
      sh_dossier_id, plausimeldung_id, alt_wert, neue_wert, befehl)
      VALUES
      ( :dossier_id, :plausimeldung_id, :alter_wert, :neuer_wert, :befehl) ';

 l_update_stmt := 'UPDATE sec_sh_dossier SET dossier_status_id = 5 WHERE sh_dossier_id = :dossier_id';
 
 l_dummy := NULL;
 
 BEGIN

     SELECT DISTINCT pm.plausimeldung_id
     INTO l_plausimeldung_id 
     FROM v_plausi p
     INNER JOIN v_plausimeldung pm ON (pm.plausi_id = p.plausi_id)
     WHERE p.alpha_code = l_plausi_nr;
     
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20001, 'Es gibt keine Plausi-Regel mit der Nummer ' || l_plausi_nr);
 END;
     -- Ermittlung der kopierten Dossiers innerhalb der Lieferung
     FOR x IN
    (
        SELECT d.sh_dossier_id, a.versichertennummer, d.jahr, d.soz_traeger_datenimport_id FROM sec_sh_dossier d
        INNER JOIN sec_antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
        INNER JOIN import_sec_selektion s ON (s.dossier_id = d.sh_dossier_id)
        WHERE s.selektion_id = p_selektion_id
        AND d.sh_flustat_id is not null
        AND d.dossier_status_id <> 5
    )
    LOOP

        -- Prüfen, ob für das kopierte Dossier ausserhalb der Lieferung ein Dublette gibt
        -- mit einem Antragsteller mit Aufenthaltsstatus 14 oder 15
        l_count := 0;

        FOR y IN
        (
             SELECT d.sh_dossier_id, a.versichertennummer FROM sec_sh_dossier d
             INNER JOIN sec_antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
             WHERE d.jahr = x.jahr AND a.aufenthaltsstatus_id IN (14,15)
             AND x.versichertennummer = a.versichertennummer
             AND d.dossier_status_id <> 5
             AND d.soz_traeger_datenimport_id <> x.soz_traeger_datenimport_id
        )
        LOOP
            l_count := l_count + 1;

            -- Imputationsmeldung für das kopierte Dossier schreiben
            IF l_count = 1 THEN
                 SELECT TO_CHAR(dossier_status_id) INTO l_alter_wert FROM sec_sh_dossier WHERE sh_dossier_id = x.sh_dossier_id; 
                 EXECUTE IMMEDIATE l_update_stmt USING x.sh_dossier_id;
                 EXECUTE IMMEDIATE l_sql_stmt
                 USING x.sh_dossier_id, l_plausimeldung_id, l_alter_wert, '5', l_update_stmt;
            END IF;

            -- Imputationsmeldung für die gefundenen Dubletten schreiben
            EXECUTE IMMEDIATE l_sql_stmt
            USING y.sh_dossier_id, l_plausimeldung_id,  l_dummy, l_dummy, l_dummy;

        END LOOP;

    END LOOP;
  
END;



PROCEDURE SP_DUMMY(p_selektion_id IN INTEGER, p_result OUT INTEGER, p_datenimport_id IN INTEGER, p_standort_id IN INTEGER, p_data_context IN INTEGER)
IS
BEGIN

  p_result := 0;

END;




--Ajout IMPUTATIONS STG



/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   SP_IMPUTATIONS
   Version 1.0   22.05.2013   STG
   Procédure principale qui pilote les imputations. Les imputations sont reprise de la table v_plausi
   Version 1.1   13.06.2013   Oliver Heiler, Concevis AG
   Erste lauffähige Implementation
   Version 1.2   19.11.2013   Oliver Heiler, Concevis AG
   Neue Tabelle import_sec_selektion => Durch Flüstat-Kopien entstehen neue sh_dossier_id, welche nicht in den Primärdaten
   vorhanden sind, Tabelle import_selektion kann hier nicht mehr verwendet werden, da diese Tabelle sh_dossier.sh_dossier 
   referenziert. Die neue Tabelle import_sec_selektion referenziert nun sec_sh_dossier.sh_dossier_id
* -------------------------------------------------------------------------- */

   PROCEDURE SP_IMPUTATION_EX ( p_datenimport_id INTEGER, p_standort_id INTEGER, p_debug_option INTEGER)
   IS

   l_selektion_id          selektion.selektion_id%TYPE := NULL;
   debug_option            INTEGER;
   l_imputation_statement  VARCHAR2(4000);
   l_selection_dossiers    VARCHAR2(4000);
   param1                  INTEGER;
   param2                  INTEGER;
   param3                  INTEGER;
   l_result                INTEGER;
   l_dossier_id            INTEGER;
   l_alter_wert            VARCHAR(32);
   l_neuer_wert            VARCHAR(32);
   l_dbg_statement         VARCHAR(512);
   l_erhebungsjahr         INTEGER;
   l_data_context          INTEGER;
   l_plausimeldung_id      INTEGER;
   
   BEGIN
    
   l_result := 0;
   l_data_context := DO_TEST_DBL_2.C_SEKUNDAERDATEN;
   
   IF p_debug_option = 1 THEN
        DELETE dbg_test_imputation;
        COMMIT;
   END IF;

   SELECT SELEKTION_SEQUENZ.NEXTVAL
   INTO l_selektion_id
   FROM DUAL;

      
   -- Rempli la table import_selektion --------------
   INSERT INTO
   import_sec_selektion (selektion_id, dossier_id, leistungsfilter_id, kanton_id )
   SELECT
   l_selektion_id, d.sh_dossier_id, l.sh_leistungsfilter_id, g.kanton_id
   FROM sec_sh_dossier d, v_sh_leistungstyp l, v_gemeinde g
   WHERE d.sh_leistungstyp_id = l.sh_leistungstyp_id
   AND d.soz_traeger_datenimport_id = p_datenimport_id
   AND d.standort_id = p_standort_id
   AND d.gemeinde_id = g.gemeinde_id;
   
   --------------------------------------------------
   SELECT jahr INTO l_erhebungsjahr 
   FROM soz_traeger_lieferung
   INNER JOIN soz_traeger_datenimport
   ON ( soz_traeger_datenimport.soz_traeger_lieferung_id = soz_traeger_lieferung.soz_traeger_lieferung_id AND 
        soz_traeger_datenimport.standort_id = soz_traeger_lieferung.standort_id)
   WHERE soz_traeger_datenimport.soz_traeger_datenimport_id = p_datenimport_id AND soz_traeger_datenimport.standort_id = p_standort_id;
   
 --  Ne pas lancer cette partie, on garde la trace des imputations
 --  DELETE FROM sh_dossier_plausi WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id;
 --  19.11.2013 : Remplacement de "proc" par "update_proc"
   FOR x IN (

      SELECT DISTINCT pm.plausimeldung_id, p.leistungsfilter, p.kanton_id, p.from_bedingung, p.where_bedingung, p.and_bedingung,
                      p.select_wert_vor_update, p.update_bedingung, p.update_reihenfolge,
                      p.update_proc, pm.param1, pm.param2, pm.param3, p.plausi_id
      FROM v_plausi p
      INNER JOIN v_plausimeldung pm ON pm.plausi_id = p.plausi_id
      INNER JOIN (
               SELECT DISTINCT i.leistungsfilter_id, i.kanton_id
               FROM import_sec_selektion i
               WHERE i.selektion_id = l_selektion_id

      ) s ON ',' || REPLACE(p.leistungsfilter, ' ', '') || ',' LIKE '%,' || s.leistungsfilter_id || ',%'
      
      WHERE (p.kanton_id is null OR  TO_CHAR(s.kanton_id) IN p.kanton_id)
      
      AND p.b_aktiv_isos_imputation = 1
      ORDER BY p.UPDATE_REIHENFOLGE
      

   ) LOOP
      
     l_plausimeldung_id := x.plausimeldung_id;
     
     IF x.update_proc is not NULL THEN
     BEGIN

      l_imputation_statement :=  'BEGIN ' || x.update_proc || '(:sel_id, :result, :datenimport_id, :standort_id, :data_context); END;';
    
      IF p_debug_option = 1 THEN
        INSERT INTO dbg_test_imputation (plausimeldung_id, sql_statement) VALUES (x.plausimeldung_id, l_imputation_statement); --ajout autres champs journalisation
        COMMIT;
      END IF;
     
      EXECUTE IMMEDIATE l_imputation_statement USING IN l_selektion_id, OUT l_result, IN p_datenimport_id, IN p_standort_id, IN l_data_context;
             
      IF (l_result < 0) THEN
          raise_application_error(-20000, 'Fehler in Prozedur' || x.update_proc || ' aufgetreten.');
      END IF;
        
     END;
     ELSE
     
/*------------------------------------------------------------------------------

*** BFS comments

** Modification 30.07.2013 : 
     
Added "DISTINCT" to the "s.dossier" SELECT in the FROM clause of the INSERT 
statement construction below. Since we want to make the INSERT in SH_DOSSIER_IMPUTATION, the 
combination of "dossier_id" and "plausimeldung_id" must be unique. 

**  Modification 05.08.2013 :

Following the propositions of release note chap. 3 for ISOS v. 6.4, we added a column
in the "x" cursor : p.plausi_id.

This addition comes for another modification at the top end of the INSERT statement below :
"AND (sh_dossier.b_neubezuegerrecord = 1 OR '|| x.plausi_id || 'in (200050))".

Plausi_id n°200050 = <Aafs-02>.

**STG  Modification 14.10.2013 :
Lower eingefügt fur Teil des konvertierung der Tabellen-Namen vom Primärdaten auf Tabellen-Namen Sekondärdaten
   
------------------------------------------------------------------------------*/
     
     
     
     BEGIN
            l_selection_dossiers:=    
            '   SELECT DISTINCT(s.dossier_id) ' ||
            '   FROM ' || REPLACE(REPLACE(REPLACE(x.from_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr) || ' INNER JOIN import_sec_selektion s ON (sh_dossier.sh_dossier_id = s.dossier_id) ' ||
            '   WHERE (' || REPLACE(REPLACE(REPLACE(x.where_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr) || 
            ') ' || NVL(REPLACE(REPLACE(REPLACE(x.and_bedingung, '%datenimport_id%', p_datenimport_id), '%standort_id%', p_standort_id), '%erhebungsjahr%', l_erhebungsjahr), '') ||
            '   AND sh_dossier.sh_leistungstyp_id IN ( SELECT sh_leistungstyp_id FROM v_sh_leistungstyp WHERE sh_leistungsfilter_id = s.leistungsfilter_id) ' ||
            '   AND s.selektion_id = ' || l_selektion_id ||
            '   AND '',' || REPLACE(x.leistungsfilter, ' ', '') || ','' LIKE ''%,'' || s.leistungsfilter_id || '',%''' ||
                CASE WHEN x.kanton_id is not null THEN ' s.kanton_id IN (' || x.kanton_id || ')' ELSE '' END  ||
            '   AND (sh_dossier.b_neubezuegerrecord = 1 OR '|| x.plausi_id || 'in (200050)) ';
      
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'antragsteller','sec_antragsteller'),'sec_antragsteller_id','antragsteller_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'hh_person','sec_hh_person'),'sec_hh_person_id','hh_person_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_ausgabe','sec_sh_ausgabe'),'sec_sh_ausgabe_id','sh_ausgabe_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_auszahlung_monat','sec_sh_auszahlung_monat'),'sec_sh_auszahlung_monat_id','sh_auszahlung_monat_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_bedarf','sec_sh_bedarf'),'sec_sh_bedarf_id','sh_bedarf_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_dossier','sec_sh_dossier'),'sec_sh_dossier_id','sh_dossier_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_massnahme','sec_massnahme'),'sec_sh_massnahme_id','sh_massnahme_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_merkmal','sec_merkmal'),'sec_sh_merkmal_id','sh_merkmal_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_wbsl_einkommen','sec_sh_wbsl_einkommen'),'sec_sh_wbsl_einkommen_id','sh_wbsl_einkommen_id');
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'sh_zusatzeinkommen','sec_sh_zusatzeinkommen'),'sec_sh_zusatzeinkommen_id','sh_zusatzeinkommen_id'); 
            l_selection_dossiers := replace(replace(lower(l_selection_dossiers), 'ue_person','sec_ue_person'),'sec_ue_person_id','ue_person_id');
            
            -- TODO: weitere Umbenennungen z.b. VW_NichtLeerePersonen => VW_SEC_NichtLeerePersonen etc.
            
            l_dbg_statement := NULL;
            
            DECLARE
            TYPE PlausiCur IS REF CURSOR; 
            plausiTyp   PlausiCur;  
            
            BEGIN
             IF x.param1 IS NULL THEN
                 OPEN plausiTyp FOR l_selection_dossiers;
              ELSE
                 IF x.param2 IS NULL THEN 
                    OPEN plausiTyp FOR l_selection_dossiers USING x.param1;
                  ELSE
                      IF x.param3 IS NULL THEN
                         OPEN plausiTyp FOR l_selection_dossiers USING x.param1, x.param2;
                      ELSE
                          OPEN plausiTyp FOR l_selection_dossiers USING x.param1, x.param2, x.param3;
                      END IF;
                   END IF;
              END IF;
              
              LOOP
              FETCH plausiTyp INTO l_dossier_id;  
              EXIT WHEN plausiTyp%NOTFOUND;

              IF x.select_wert_vor_update is not null THEN
              BEGIN
                  IF x.param1 IS NULL THEN
                    BEGIN
                      EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_alter_wert USING l_dossier_id;
                      EXECUTE IMMEDIATE x.update_bedingung USING l_dossier_id;
                      EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_neuer_wert USING l_dossier_id;
                      EXCEPTION
                      WHEN NO_DATA_FOUND THEN
                        l_alter_wert := NULL;
                        l_neuer_wert := NULL;
                    END;
                  ELSE
                    IF x.param2 IS NULL THEN
                       BEGIN
                        EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_alter_wert USING l_dossier_id, x.param1;
                        EXECUTE IMMEDIATE x.update_bedingung USING l_dossier_id, x.param1;
                        EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_neuer_wert USING l_dossier_id, x.param1;
                        EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                          l_alter_wert := NULL;
                          l_neuer_wert := NULL;
                       END;
                    ELSE
                      IF x.param3 IS NULL THEN
                        BEGIN
                          EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_alter_wert USING l_dossier_id, x.param1, x.param2;
                          EXECUTE IMMEDIATE x.update_bedingung USING l_dossier_id, x.param1, x.param2;
                          EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_neuer_wert USING l_dossier_id, x.param1, x.param2;
                          EXCEPTION
                          WHEN NO_DATA_FOUND THEN
                            l_alter_wert := NULL;
                            l_neuer_wert := NULL;
                        END;
                      ELSE
                        BEGIN
                          EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_alter_wert USING l_dossier_id, x.param1, x.param2, x.param3;
                          EXECUTE IMMEDIATE x.update_bedingung USING l_dossier_id, x.param1, x.param2, x.param3;
                          EXECUTE IMMEDIATE x.select_wert_vor_update INTO l_neuer_wert USING l_dossier_id, x.param1, x.param2, x.param3;
                          EXCEPTION
                          WHEN NO_DATA_FOUND THEN
                            l_alter_wert := NULL;
                            l_neuer_wert := NULL;
                        END;
                      END IF;
                    END IF;
                  END IF;
                  
                  l_dbg_statement := REPLACE(x.update_bedingung, ':doss_id', l_dossier_id);
                  l_dbg_statement := REPLACE(l_dbg_statement, ':param1', x.param1);
                  l_dbg_statement := REPLACE(l_dbg_statement, ':param2', x.param2);
                  l_dbg_statement := REPLACE(l_dbg_statement, ':param3', x.param3);
                  
                  IF p_debug_option = 1 THEN
                    INSERT INTO dbg_test_imputation (plausimeldung_id, sql_statement) VALUES (x.plausimeldung_id, l_dbg_statement);
                    COMMIT;
                  END IF;
        
                  INSERT INTO sh_dossier_imputation (sh_dossier_id, plausimeldung_id, variable, alt_wert, neue_wert, befehl, update_reihenfolge)
                  VALUES (l_dossier_id, x.plausimeldung_id, NULL, l_alter_wert, l_neuer_wert, l_dbg_statement, x.update_reihenfolge);
              END;    
              END IF;
              END LOOP;
              CLOSE plausiTyp;
              
            END;
     END;
     END IF;

   END LOOP;

   DELETE FROM
      import_sec_selektion
   WHERE
      selektion_id = l_selektion_id;

    EXCEPTION
      WHEN OTHERS THEN
      DELETE FROM import_sec_selektion
      WHERE selektion_id = l_selektion_id;
      DBG_TEST_IMPUTATION (l_plausimeldung_id, l_selection_dossiers);
      COMMIT;
      RAISE;

   --COMMIT;

   END;
   
   PROCEDURE DBG_TEST_IMPUTATION ( p_plausimeldung_id INTEGER, p_sql_statement VARCHAR2)
   IS
   PRAGMA  AUTONOMOUS_TRANSACTION;
   BEGIN
      DELETE dbg_test_imputation;
      INSERT INTO dbg_test_imputation (plausimeldung_id, sql_statement) VALUES (p_plausimeldung_id, p_sql_statement);
      COMMIT;
   END;
   
END;

/
create or replace 
PACKAGE BODY do_mass_op  IS
   -- Enter procedure, function bodies as shown below

   FUNCTION f_haushalte_anlegen(p_jahr IN INTEGER)

   RETURN INTEGER IS
      -- Enter the procedure variables here. As shown below
   varHaushaltID INTEGER;

   CURSOR curs IS
        SELECT sh_dossier_id,sh_leistungstyp_id, sh_wohnsituation_id, wohnungsgroesse_id,
        anz_personen_hh, anz_pflegefaelle_hh, wohnkosten_inkl_nk
        FROM sh_dossier
        WHERE nvl ( sh_haushalt_id, 0) = 0
        AND jahr = p_jahr;

   curs_row    curs%ROWTYPE;

   BEGIN

      OPEN curs;

      LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         SELECT  NEXT_ID.nextval INTO varHaushaltID FROM DUAL;

         INSERT INTO sh_haushalt
         (sh_haushalt_id, sh_leistungstyp_id, sh_wohnsituation_id, wohnungsgroesse_id,
          anz_personen_hh, anz_pflegefaelle_hh, wohnkosten_inkl_hh)
         VALUES
         (varHaushaltID,curs_row.sh_leistungstyp_id, curs_row.sh_wohnsituation_id, curs_row.wohnungsgroesse_id,
          curs_row.anz_personen_hh, curs_row.anz_pflegefaelle_hh, curs_row.wohnkosten_inkl_nk);

          UPDATE sh_dossier SET sh_haushalt_id = varHaushaltID WHERE sh_dossier_id = curs_row.sh_dossier_id;

       END LOOP;

      CLOSE curs;

   RETURN 0;
   END;

   FUNCTION f_haushalte_verknuepfen(p_jahr IN INTEGER)

   RETURN INTEGER IS
      -- Enter the procedure variables here. As shown below

   BEGIN
    DBMS_OUTPUT.PUT_LINE ('Test');

    RETURN 0;
   END;


  /* FUNCTION  F_PLAUSIS_PRO_JAHR (p_jahr IN Integer)
    RETURN INTEGER IS
    CURSOR curs IS
       SELECT   r.sh_dossier_id
        FROM    roh_sh_dossier r
        WHERE   r.jahr = p_jahr;

    curs_row    curs%ROWTYPE;

    BEGIN
        DO_PLAUSI.SP_PLAUSI_JAHR_100001(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100002(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100003(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100004(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100005(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100006(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100007(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100013(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100014(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100015(p_jahr);
        DO_PLAUSI.SP_PLAUSI_JAHR_100016(p_jahr);
        OPEN curs;

       LOOP
            FETCH curs INTO curs_row;
            EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;
            DO_PLAUSI.SP_PLAUSI_100008_9(curs_row.sh_dossier_id);
            DO_PLAUSI.SP_PLAUSI_100010(curs_row.sh_dossier_id);
            DO_PLAUSI.SP_PLAUSI_100011(curs_row.sh_dossier_id);
        END LOOP;
        CLOSE curs;
     RETURN 0;
   END;*/

--******************************************************************************************************************--
/* ---------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.00   10.02.2009   Olivier Wirz, BFS
   Grund:         abgebr_ausbildung_id, Werte 1 und 2, müssen nicht mehr
                  in -12 transformiert werden.

   Version 1.01   07.04.2009   Oliver Heiler, Concevis AG
   Grund:         Felder zvr_strasse, zvr_haus_nr hinzufügen

* -------------------------------------------------------------------------- */
  PROCEDURE SP_COPY_ROH_ANTRAGSTELLER(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER, p_ep_jahr IN INTEGER)
  IS
    --v_cur               INTEGER;
    --v_rows_processed    INTEGER;

  CURSOR curs IS
  SELECT sh_dossier_id,
                    F_TRANSFER_INVALID_CONSTRAINT3(geschlecht_id, 'v_geschlecht', 'geschlecht_id') as geschlecht_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zivilstand_id, 'v_zivilstand', 'zivilstand_id') as zivilstand_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(nationalitaet_land_id, 'v_land', 'land_id') as nationalitaet_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(aufenthaltsstatus_id, 'v_aufenthaltsstatus', 'aufenthaltsstatus_id') as aufenthaltsstatus_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(buerger_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as buerger_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_gem_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as zuzug_gem_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_gem_land_id, 'v_land', 'land_id') as zuzug_gem_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_kant_kanton_id, 'v_kanton', 'kanton_id') as zuzug_kant_kanton_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_kant_land_id, 'v_land', 'land_id') as  zuzug_kant_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zvr_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as zvr_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(auf_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as auf_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(ust_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as ust_gemeinde_id,
                     zvr_ort, zvr_plz, ust_ort, ust_plz, auf_ort, auf_plz,
                     F_TRANSFER_INVALID_CONSTRAINT3(ausbildung_id, 'v_ausbildung', 'ausbildung_id') as ausbildung_id,
                      /*DECODE(abgebr_ausbildung_id, 1, -12, 2, -12, F_TRANSFER_INVALID_CONSTRAINT(abgebr_ausbildung_id, 'v_ausbildung', 'ausbildung_id')) as abgebr_ausbildung_id,*/
                     F_TRANSFER_INVALID_CONSTRAINT3(abgebr_ausbildung_id, 'v_ausbildung', 'ausbildung_id') as abgebr_ausbildung_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(erlernter_beruf_id, 'v_beruf', 'beruf_id') as erlernter_beruf_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(aktueller_beruf_id, 'v_beruf', 'beruf_id') as aktueller_beruf_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(beschaeftigungsgrad_id, 'v_beschaeftigungsgrad', 'beschaeftigungsgrad_id') as beschaeftigungsgrad_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(branche_id, 'v_branche', 'branche_id') as branche_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(teilzeit_grund1_id, 'v_teilzeit_grund', 'teilzeit_grund_id') as teilzeit_grund1_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(teilzeit_grund2_id, 'v_teilzeit_grund', 'teilzeit_grund_id') as teilzeit_grund2_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(invaliditaetsgrad_id, 'v_invaliditaetsgrad', 'invaliditaetsgrad_id') as invaliditaetsgrad_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(hilflosigkeitsgrad_id, 'v_hilflosigkeitsgrad', 'hilflosigkeitsgrad_id') as hilflosigkeitsgrad_id,
                     F_TRANSFER_MISSING_AHV_NR(ahv_nr8) as ahv_nr8, F_TRANSFER_MISSING_AHV_NR(ahv_nr3) as ahv_nr3,
                     F_TRANSFER_INVALID_DATE_SD(dat_geburt, p_ep_jahr) as dat_geburt,
                     F_TRANSFER_INVALID_DATE_SD(dat_in_gemeinde_seit, p_ep_jahr) as dat_in_gemeinde_seit,
                     F_TRANSFER_INVALID_DATE_SD(dat_im_kanton_seit, p_ep_jahr) as dat_im_kanton_seit,
                     in_ch_seit_jahr, DECODE(b_allein_im_hh,1,1,2,2,-9,-9,-12) as b_allein_im_hh, b_arbeit_unregelmaessig, arbeitszeit_woche,
                     F_TRANSFER_INVALID_DATE_SD(dat_stempelbeginn,p_ep_jahr) as dat_stempelbeginn,
                     b_ausgesteuert,
                     F_TRANSFER_INVALID_DATE_SD(dat_ausgesteuert,p_ep_jahr) as dat_ausgesteuert,
                     anz_arbeitslos_3j, b_ausb_abgebrochen, b_iv_eingliederung,
                     b_kk_grundversicherung, b_kk_zusatzversicherung, kk_name,
                     kk_praemie_mt, b_kk_praemienzuschuss, kk_zuschuss_betrag,
                     betrag_mietanteil, b_plausiproblem, versichertennummer,
                     zvr_strasse, zvr_haus_nr
  FROM roh_antragsteller
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN
    --v_cur := DBMS_SQL.OPEN_CURSOR;
  OPEN curs;

  FETCH curs INTO curs_row;

  INSERT INTO antragsteller (sh_dossier_id, geschlecht_id,
                     zivilstand_id, nationalitaet_land_id,
                     aufenthaltsstatus_id, buerger_gemeinde_id, zuzug_gem_gemeinde_id,
                     zuzug_gem_land_id, zuzug_kant_kanton_id, zuzug_kant_land_id,
                     zvr_gemeinde_id, auf_gemeinde_id, ust_gemeinde_id,
                     zvr_ort, zvr_plz, ust_ort, ust_plz, auf_ort, auf_plz,
                     ausbildung_id, abgebr_ausbildung_id, erlernter_beruf_id,
                     aktueller_beruf_id, beschaeftigungsgrad_id, branche_id,
                     teilzeit_grund1_id, teilzeit_grund2_id, invaliditaetsgrad_id,
                     hilflosigkeitsgrad_id, ahv_nr8, ahv_nr3, dat_geburt,
                     dat_in_gemeinde_seit, dat_im_kanton_seit, in_ch_seit_jahr,
                     b_allein_im_hh, b_arbeit_unregelmaessig, arbeitszeit_woche,
                     dat_stempelbeginn, b_ausgesteuert, dat_ausgesteuert,
                     anz_arbeitslos_3j, b_ausb_abgebrochen, b_iv_eingliederung,
                     b_kk_grundversicherung, b_kk_zusatzversicherung, kk_name,
                     kk_praemie_mt, b_kk_praemienzuschuss, kk_zuschuss_betrag,
                     betrag_mietanteil, b_plausiproblem, versichertennummer,
                     zvr_strasse, zvr_haus_nr )
  VALUES (           curs_row.sh_dossier_id, curs_row.geschlecht_id,
                     curs_row.zivilstand_id, curs_row.nationalitaet_land_id,
                     curs_row.aufenthaltsstatus_id, curs_row.buerger_gemeinde_id, curs_row.zuzug_gem_gemeinde_id,
                     curs_row.zuzug_gem_land_id, curs_row.zuzug_kant_kanton_id, curs_row.zuzug_kant_land_id,
                     curs_row.zvr_gemeinde_id, curs_row.auf_gemeinde_id, curs_row.ust_gemeinde_id,
                     curs_row.zvr_ort, curs_row.zvr_plz, curs_row.ust_ort, curs_row.ust_plz, curs_row.auf_ort, curs_row.auf_plz,
                     curs_row.ausbildung_id, curs_row.abgebr_ausbildung_id, curs_row.erlernter_beruf_id,
                     curs_row.aktueller_beruf_id, curs_row.beschaeftigungsgrad_id, curs_row.branche_id,
                     curs_row.teilzeit_grund1_id, curs_row.teilzeit_grund2_id, curs_row.invaliditaetsgrad_id,
                     curs_row.hilflosigkeitsgrad_id, curs_row.ahv_nr8, curs_row.ahv_nr3, curs_row.dat_geburt,
                     curs_row.dat_in_gemeinde_seit, curs_row.dat_im_kanton_seit, curs_row.in_ch_seit_jahr,
                     curs_row.b_allein_im_hh, curs_row.b_arbeit_unregelmaessig, curs_row.arbeitszeit_woche,
                     curs_row.dat_stempelbeginn, curs_row.b_ausgesteuert, curs_row.dat_ausgesteuert,
                     curs_row.anz_arbeitslos_3j, curs_row.b_ausb_abgebrochen, curs_row.b_iv_eingliederung,
                     curs_row.b_kk_grundversicherung, curs_row.b_kk_zusatzversicherung, curs_row.kk_name,
                     curs_row.kk_praemie_mt, curs_row.b_kk_praemienzuschuss, curs_row.kk_zuschuss_betrag,
                     curs_row.betrag_mietanteil,curs_row.b_plausiproblem, curs_row.versichertennummer,
                     curs_row.zvr_strasse, curs_row.zvr_haus_nr );

  CLOSE curs;

  END;

/* --------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.01   09.10.2008   Oliver Heiler, Concevis AG
   Grund:         Versichertennummer hinzugefügt

   Version 1.02   04.11.2008 Oliver Heiler, Concevis AG
   Grund:         Branche-ID wieder numerisch, F_TRANSFER_INVALID_CONSTRAINT2(branche_id)
                  -> F_TRANSFER_INVALID_CONSTRAINT(branche_id)

   Version 1.03   10.02.2009   Olivier Wirz, BFS
   Grund:         abgebr_ausbildung_id, Werte 1 und 2, müssen nicht mehr
                  in -12 transformiert werden.

   Version 1.04   07.04.2009   Oliver Heiler, Concevis AG
   Grund:         Felder zvr_strasse, zvr_haus_nr hinzufügen

   ISOS 5.0
   ********
   Version 1.1    24.11.2009   Oliver Heiler, Concevis AG
   Grund:         Neuer Übergabe-Parameter Leistungstyp des Dossiers (wird neu für F_TRANSFER_INVALID_CONSTRAINT benötigt)

* -------------------------------------------------------------------------- */
PROCEDURE SP_COPY_ROH_ANTR_COMPLETE(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER, p_ep_jahr IN INTEGER)
  IS
    --v_cur               INTEGER;
    --v_rows_processed    INTEGER;

  CURSOR curs IS
  SELECT sh_dossier_id,
                    F_TRANSFER_INVALID_CONSTRAINT3(geschlecht_id, 'v_geschlecht', 'geschlecht_id') as geschlecht_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zivilstand_id, 'v_zivilstand', 'zivilstand_id') as zivilstand_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(nationalitaet_land_id, 'v_land', 'land_id') as nationalitaet_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(aufenthaltsstatus_id, 'v_aufenthaltsstatus', 'aufenthaltsstatus_id') as aufenthaltsstatus_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(buerger_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as buerger_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(zuzug_gem_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as zuzug_gem_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_gem_land_id, 'v_land', 'land_id') as zuzug_gem_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(zuzug_kant_kanton_id, 'v_kanton', 'kanton_id') as zuzug_kant_kanton_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(zuzug_kant_land_id, 'v_land', 'land_id') as  zuzug_kant_land_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(zvr_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as zvr_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(auf_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as auf_gemeinde_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(ust_gemeinde_id, 'v_gemeinde', 'gemeinde_id') as ust_gemeinde_id,
                     zvr_ort, zvr_plz, ust_ort, ust_plz, auf_ort, auf_plz,
                     F_TRANSFER_INVALID_CONSTRAINT3(ausbildung_id, 'v_ausbildung', 'ausbildung_id') as ausbildung_id,
                     /*DECODE(abgebr_ausbildung_id, 1, -12, 2, -12, F_TRANSFER_INVALID_CONSTRAINT(abgebr_ausbildung_id, 'v_ausbildung', 'ausbildung_id')) as abgebr_ausbildung_id,*/
                     F_TRANSFER_INVALID_CONSTRAINT3(abgebr_ausbildung_id, 'v_ausbildung', 'ausbildung_id') as abgebr_ausbildung_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(erlernter_beruf_id, 'v_beruf', 'beruf_id') as erlernter_beruf_id,
                     F_TRANSFER_INVALID_CONSTRAINT4(aktueller_beruf_id, 'v_beruf', 'beruf_id') as aktueller_beruf_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(beschaeftigungsgrad_id, 'v_beschaeftigungsgrad', 'beschaeftigungsgrad_id') as beschaeftigungsgrad_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(branche_id, 'v_branche', 'branche_id') as branche_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(teilzeit_grund1_id, 'v_teilzeit_grund', 'teilzeit_grund_id') as teilzeit_grund1_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(teilzeit_grund2_id, 'v_teilzeit_grund', 'teilzeit_grund_id') as teilzeit_grund2_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(invaliditaetsgrad_id, 'v_invaliditaetsgrad', 'invaliditaetsgrad_id') as invaliditaetsgrad_id,
                     F_TRANSFER_INVALID_CONSTRAINT3(hilflosigkeitsgrad_id, 'v_hilflosigkeitsgrad', 'hilflosigkeitsgrad_id') as hilflosigkeitsgrad_id,
                     F_TRANSFER_MISSING_AHV_NR(ahv_nr8) as ahv_nr8, F_TRANSFER_MISSING_AHV_NR(ahv_nr3) as ahv_nr3,
                     F_TRANSFER_INVALID_DATE_SD(dat_geburt, p_ep_jahr) as dat_geburt,
                     F_TRANSFER_INVALID_DATE_SD(dat_in_gemeinde_seit, p_ep_jahr) as dat_in_gemeinde_seit,
                     F_TRANSFER_INVALID_DATE_SD(dat_im_kanton_seit, p_ep_jahr) as dat_im_kanton_seit,
                     in_ch_seit_jahr, DECODE(b_allein_im_hh,1,1,2,2,-9,-9,-12) as b_allein_im_hh, b_arbeit_unregelmaessig, arbeitszeit_woche,
                     F_TRANSFER_INVALID_DATE_SD(dat_stempelbeginn,p_ep_jahr) as dat_stempelbeginn,
                     b_ausgesteuert,
                     F_TRANSFER_INVALID_DATE_SD(dat_ausgesteuert,p_ep_jahr) as dat_ausgesteuert,
                     anz_arbeitslos_3j, b_ausb_abgebrochen, b_iv_eingliederung,
                     b_kk_grundversicherung, b_kk_zusatzversicherung, kk_name,
                     kk_praemie_mt, b_kk_praemienzuschuss, kk_zuschuss_betrag,
                     betrag_mietanteil, b_plausiproblem, versichertennummer,
                     zvr_strasse, zvr_haus_nr
  FROM roh_antragsteller
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN
    --v_cur := DBMS_SQL.OPEN_CURSOR;
  OPEN curs;

  FETCH curs INTO curs_row;

  INSERT INTO antragsteller (sh_dossier_id, geschlecht_id,
                     zivilstand_id, nationalitaet_land_id,
                     aufenthaltsstatus_id, buerger_gemeinde_id, zuzug_gem_gemeinde_id,
                     zuzug_gem_land_id, zuzug_kant_kanton_id, zuzug_kant_land_id,
                     zvr_gemeinde_id, auf_gemeinde_id, ust_gemeinde_id,
                     zvr_ort, zvr_plz, ust_ort, ust_plz, auf_ort, auf_plz,
                     ausbildung_id, abgebr_ausbildung_id, erlernter_beruf_id,
                     aktueller_beruf_id, beschaeftigungsgrad_id, branche_id,
                     teilzeit_grund1_id, teilzeit_grund2_id, invaliditaetsgrad_id,
                     hilflosigkeitsgrad_id, ahv_nr8, ahv_nr3, dat_geburt,
                     dat_in_gemeinde_seit, dat_im_kanton_seit, in_ch_seit_jahr,
                     b_allein_im_hh, b_arbeit_unregelmaessig, arbeitszeit_woche,
                     dat_stempelbeginn, b_ausgesteuert, dat_ausgesteuert,
                     anz_arbeitslos_3j, b_ausb_abgebrochen, b_iv_eingliederung,
                     b_kk_grundversicherung, b_kk_zusatzversicherung, kk_name,
                     kk_praemie_mt, b_kk_praemienzuschuss, kk_zuschuss_betrag,
                     betrag_mietanteil, b_plausiproblem, versichertennummer,
                     zvr_strasse, zvr_haus_nr  )
  VALUES (           curs_row.sh_dossier_id, curs_row.geschlecht_id,
                     curs_row.zivilstand_id, curs_row.nationalitaet_land_id,
                     curs_row.aufenthaltsstatus_id, curs_row.buerger_gemeinde_id, curs_row.zuzug_gem_gemeinde_id,
                     curs_row.zuzug_gem_land_id, curs_row.zuzug_kant_kanton_id, curs_row.zuzug_kant_land_id,
                     curs_row.zvr_gemeinde_id, curs_row.auf_gemeinde_id, curs_row.ust_gemeinde_id,
                     curs_row.zvr_ort, curs_row.zvr_plz, curs_row.ust_ort, curs_row.ust_plz, curs_row.auf_ort, curs_row.auf_plz,
                     curs_row.ausbildung_id, curs_row.abgebr_ausbildung_id, curs_row.erlernter_beruf_id,
                     curs_row.aktueller_beruf_id, curs_row.beschaeftigungsgrad_id, curs_row.branche_id,
                     curs_row.teilzeit_grund1_id, curs_row.teilzeit_grund2_id, curs_row.invaliditaetsgrad_id,
                     curs_row.hilflosigkeitsgrad_id, curs_row.ahv_nr8, curs_row.ahv_nr3, curs_row.dat_geburt,
                     curs_row.dat_in_gemeinde_seit, curs_row.dat_im_kanton_seit, curs_row.in_ch_seit_jahr,
                     curs_row.b_allein_im_hh, curs_row.b_arbeit_unregelmaessig, curs_row.arbeitszeit_woche,
                     curs_row.dat_stempelbeginn, curs_row.b_ausgesteuert, curs_row.dat_ausgesteuert,
                     curs_row.anz_arbeitslos_3j, curs_row.b_ausb_abgebrochen, curs_row.b_iv_eingliederung,
                     curs_row.b_kk_grundversicherung, curs_row.b_kk_zusatzversicherung, curs_row.kk_name,
                     curs_row.kk_praemie_mt, curs_row.b_kk_praemienzuschuss, curs_row.kk_zuschuss_betrag,
                     curs_row.betrag_mietanteil,curs_row.b_plausiproblem, curs_row.versichertennummer,
                     curs_row.zvr_strasse, curs_row.zvr_haus_nr );

  CLOSE curs;

  SP_COPY_ROH_SH_MASSNAHME(p_sh_leistungstyp_id,p_sh_dossier_id);
  SP_COPY_ROH_SH_AUSGABE(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_SH_BEDARF(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_SH_ZUSATZEINKOMMEN(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_ANTRAGSTELLER_EINK(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_ANTRAGSTELLER_ERWS(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_UE_PERSON(p_sh_leistungstyp_id, p_sh_dossier_id, p_ep_jahr);
  SP_COPY_ROH_UE_PERSON_EINK(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_UE_PERSON_ERWS(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_HH_PERSON(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_SH_MERKMAL(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_SH_AUSZ_MONAT(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_ANTRAGST_BEDARF(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_UE_PERSON_BEDARF(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_SH_WBSL_EINKOMMEN(p_sh_leistungstyp_id, p_sh_dossier_id);
  SP_COPY_ROH_ANTR_ALBV(p_sh_leistungstyp_id, p_sh_dossier_id, p_ep_jahr);
  SP_COPY_ROH_UE_PERSON_ALBV(p_sh_leistungstyp_id, p_sh_dossier_id, p_ep_jahr);

  END;
  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_SH_MASSNAHME(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT massnahme_id, kommentar, b_plausiproblem
  FROM roh_sh_massnahme
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_massnahme (sh_dossier_id, massnahme_id, kommentar, b_plausiproblem)
         VALUES (p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.massnahme_id, 'v_massnahme', 'massnahme_id'), curs_row.kommentar, curs_row.b_plausiproblem);


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_SH_AUSGABE(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT ausgabeart_id, betrag, b_plausiproblem, b_in_abklaerung
  FROM roh_sh_ausgabe
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_ausgabe (sh_dossier_id, ausgabeart_id, betrag, b_plausiproblem, b_in_abklaerung)
         VALUES (p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.ausgabeart_id, 'v_ausgabeart', 'ausgabeart_id'),
                 curs_row.betrag, curs_row.b_plausiproblem, F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung));


     END LOOP;

     CLOSE curs;

  END;

  PROCEDURE SP_COPY_ROH_SH_ZUSATZEINKOMMEN(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT sh_einkommensart_id, betrag, b_in_abklaerung, b_plausiproblem
  FROM roh_sh_zusatzeinkommen
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_zusatzeinkommen
         (
            sh_dossier_id, sh_einkommensart_id,
            betrag, b_in_abklaerung, b_plausiproblem
         )
         VALUES
         (
            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.sh_einkommensart_id, 'v_einkommensart', 'einkommensart_id'), curs_row.betrag,
            F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung), curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_SH_BEDARF(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT bedarfsart_id, betrag, b_plausiproblem
  FROM roh_sh_bedarf
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_bedarf
         (
            sh_dossier_id, bedarfsart_id,
            betrag, b_plausiproblem
         )
         VALUES
         (
            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.bedarfsart_id, 'v_bedarfsart', 'bedarfsart_id'), curs_row.betrag, curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--
  PROCEDURE SP_COPY_ROH_SH_MERKMAL(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT sh_merkmal_id, wert, b_plausiproblem
  FROM roh_sh_merkmal
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_merkmal
         (
            sh_dossier_id, sh_merkmal_id,
            wert, b_plausiproblem
         )
         VALUES
         (
            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.sh_merkmal_id, 'v_sh_merkmal', 'sh_merkmal_id'), curs_row.wert,
            curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_SH_AUSZ_MONAT(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT monat_id, betrag, b_plausiproblem
  FROM roh_sh_auszahlung_monat
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_auszahlung_monat
         (
            sh_dossier_id, monat_id,
            betrag, b_plausiproblem
         )
         VALUES
         (
            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.monat_id, 'v_monat', 'monat_id'), curs_row.betrag,
            curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

--******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_SH_WBSL_EINKOMMEN(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT sh_einkommensart_id, b_in_abklaerung, b_plausiproblem
  FROM roh_sh_wbsl_einkommen
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO sh_wbsl_einkommen (sh_dossier_id, sh_einkommensart_id, b_in_abklaerung, b_plausiproblem )
         VALUES (p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.sh_einkommensart_id, 'v_sh_einkommensart', 'sh_einkommensart_id'), curs_row.b_in_abklaerung, curs_row.b_plausiproblem);

     END LOOP;

     CLOSE curs;

  END;
  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_ANTRAGSTELLER_EINK(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT einkommensart_id, betrag, b_in_abklaerung, b_plausiproblem
  FROM roh_antragsteller_einkommen
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO antragsteller_einkommen
         (
            sh_dossier_id, einkommensart_id,
            betrag, b_in_abklaerung, b_plausiproblem
         )
         VALUES
         (

            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.einkommensart_id, 'v_einkommensart', 'einkommensart_id'), curs_row.betrag,
            F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung), curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_ANTRAGSTELLER_ERWS(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT erwerbsituation_id, b_plausiproblem, indx
  FROM roh_antragsteller_erwerbsit
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO antragsteller_erwerbsit
         (
            sh_dossier_id, erwerbsituation_id, b_plausiproblem, indx
         )
         VALUES
         (
            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.erwerbsituation_id, 'v_erwerbsituation', 'erwerbsituation_id'), curs_row.b_plausiproblem, curs_row.indx
         );


     END LOOP;

     CLOSE curs;

  END;

PROCEDURE SP_COPY_ROH_ANTRAGST_BEDARF(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT bedarfsart_id, betrag, b_in_abklaerung, b_plausiproblem, massnahme_grund_id
  FROM roh_antragsteller_bedarf
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO antragsteller_bedarf
         (
            sh_dossier_id, bedarfsart_id,
            betrag, b_in_abklaerung, b_plausiproblem, massnahme_grund_id
         )
         VALUES
         (

            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.bedarfsart_id, 'v_bedarfsart', 'bedarfsart_id'), curs_row.betrag,
            F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung), curs_row.b_plausiproblem,
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.massnahme_grund_id, 'v_massnahme_grund', 'massnahme_grund_id')
         );


    END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_ANTR_ALBV(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER, p_ep_jahr IN INTEGER)
  IS

  CURSOR curs IS
  SELECT antragsart_id, betrag_zugesprochen, dat_erste_auszahlung, betrag_tot_auszahlungen,
  b_bezug_stichtag, dat_letzte_zahlung, b_plausiproblem
  FROM roh_antragsteller_albv
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO antragsteller_albv
         (
            sh_dossier_id, antragsart_id,
            betrag_zugesprochen, dat_erste_auszahlung, betrag_tot_auszahlungen,
            b_bezug_stichtag, dat_letzte_zahlung, b_plausiproblem
         )
         VALUES
         (

            p_sh_dossier_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.antragsart_id, 'v_antragsart', 'antragsart_id'),
            curs_row.betrag_zugesprochen, F_TRANSFER_INVALID_DATE_SD(curs_row.dat_erste_auszahlung, p_ep_jahr) ,
             curs_row.betrag_tot_auszahlungen,
            curs_row.b_bezug_stichtag, F_TRANSFER_INVALID_DATE_SD(curs_row.dat_letzte_zahlung, p_ep_jahr) ,
            curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_UE_PERSON(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER, p_ep_jahr IN INTEGER)
  IS

  CURSOR curs IS
  SELECT ue_person_id, ausbildung_id, geschlecht_id, zivilstand_id, verwandtschaftsgrad_id,
         nationalitaet_land_id, aufenthaltsstatus_id, beschaeftigungsgrad_id,
         invaliditaetsgrad_id, hilflosigkeitsgrad_id, geburtsjahr, in_ch_seit_jahr, versichertennummer
  FROM roh_ue_person
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO ue_person
         (
            sh_dossier_id,ue_person_id,
            ausbildung_id, geschlecht_id, zivilstand_id, verwandtschaftsgrad_id,
            nationalitaet_land_id, aufenthaltsstatus_id, beschaeftigungsgrad_id,
            invaliditaetsgrad_id, hilflosigkeitsgrad_id, geburtsjahr, in_ch_seit_jahr,
            versichertennummer
         )
         VALUES
         (
            p_sh_dossier_id,curs_row.ue_person_id,
           F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.ausbildung_id, 'v_ausbildung', 'ausbildung_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.geschlecht_id, 'v_geschlecht', 'geschlecht_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.zivilstand_id, 'v_zivilstand', 'zivilstand_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.verwandtschaftsgrad_id, 'v_verwandtschaftsgrad', 'verwandtschaftsgrad_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.nationalitaet_land_id, 'v_land', 'land_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.aufenthaltsstatus_id, 'v_aufenthaltsstatus', 'aufenthaltsstatus_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.beschaeftigungsgrad_id, 'v_beschaeftigungsgrad', 'beschaeftigungsgrad_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.invaliditaetsgrad_id, 'v_invaliditaetsgrad', 'invaliditaetsgrad_id'),
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.hilflosigkeitsgrad_id, 'v_hilflosigkeitsgrad', 'hilflosigkeitsgrad_id'),
            F_TRANSFER_INVALID_JAHR(curs_row.geburtsjahr, p_ep_jahr),
            curs_row.in_ch_seit_jahr,
            curs_row.versichertennummer
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_UE_PERSON_EINK(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT ue_person_id, einkommensart_id, betrag, b_in_abklaerung, b_plausiproblem
  FROM roh_ue_person_einkommen
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO ue_person_einkommen
         (
            sh_dossier_id,ue_person_id, einkommensart_id, betrag,
            b_in_abklaerung, b_plausiproblem
         )
         VALUES
         (
            p_sh_dossier_id,curs_row.ue_person_id,
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.einkommensart_id, 'v_einkommensart', 'einkommensart_id'),
            curs_row.betrag, F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung),
            curs_row.b_plausiproblem
         );


     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_UE_PERSON_ERWS(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT ue_person_id, erwerbsituation_id, b_plausiproblem, indx
  FROM roh_ue_person_erwerbsit
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO ue_person_erwerbsit
         (
            sh_dossier_id,ue_person_id, erwerbsituation_id, b_plausiproblem, indx
         )
         VALUES
         (
            p_sh_dossier_id,curs_row.ue_person_id,
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.erwerbsituation_id, 'v_erwerbsituation', 'erwerbsituation_id'),
            curs_row.b_plausiproblem, curs_row.indx
         );


     END LOOP;

     CLOSE curs;

  END;

PROCEDURE SP_COPY_ROH_UE_PERSON_BEDARF(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT ue_person_id, bedarfsart_id, betrag, b_in_abklaerung, b_plausiproblem, massnahme_grund_id
  FROM roh_ue_person_bedarf
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO ue_person_bedarf
         (
            sh_dossier_id,ue_person_id, bedarfsart_id, betrag,
            b_in_abklaerung, b_plausiproblem, massnahme_grund_id
         )
         VALUES
         (
            p_sh_dossier_id,curs_row.ue_person_id,
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.bedarfsart_id, 'v_bedarfsart', 'bedarfsart_id'),
            curs_row.betrag, F_TRANSFER_INVALID_B_IN_ABKL(curs_row.b_in_abklaerung),
            curs_row.b_plausiproblem, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.massnahme_grund_id, 'v_massnahme_grund', 'massnahme_grund_id')
         );


     END LOOP;

     CLOSE curs;

  END;


PROCEDURE SP_COPY_ROH_UE_PERSON_ALBV(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER, p_ep_jahr IN INTEGER)
  IS

 CURSOR curs IS
  SELECT ue_person_id, antragsart_id, betrag_zugesprochen, dat_erste_auszahlung, betrag_tot_auszahlungen,
  b_bezug_stichtag, dat_letzte_zahlung, b_plausiproblem
  FROM roh_ue_person_albv
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO ue_person_albv
         (
            sh_dossier_id, ue_person_id, antragsart_id,
            betrag_zugesprochen, dat_erste_auszahlung, betrag_tot_auszahlungen,
            b_bezug_stichtag, dat_letzte_zahlung, b_plausiproblem
         )
         VALUES
         (

            p_sh_dossier_id, curs_row.ue_person_id, F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.antragsart_id, 'v_antragsart', 'antragsart_id'),
            curs_row.betrag_zugesprochen, F_TRANSFER_INVALID_DATE_SD(curs_row.dat_erste_auszahlung, p_ep_jahr),
             curs_row.betrag_tot_auszahlungen,
            curs_row.b_bezug_stichtag, F_TRANSFER_INVALID_DATE_SD(curs_row.dat_letzte_zahlung, p_ep_jahr),
            curs_row.b_plausiproblem
         );



     END LOOP;

     CLOSE curs;

  END;
  --******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_HH_PERSON(p_sh_leistungstyp_id IN INTEGER, p_sh_dossier_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT hh_person_id, verwandtschaftsgrad_id, b_separate_unterstuetzung,
         ahv_nr8, ahv_nr3, b_plausiproblem, versichertennummer
  FROM roh_hh_person
  WHERE sh_dossier_id = p_sh_dossier_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO hh_person
         (
            sh_dossier_id, hh_person_id, verwandtschaftsgrad_id, b_separate_unterstuetzung,
            ahv_nr8, ahv_nr3, b_plausiproblem, versichertennummer
         )
         VALUES
         (
            p_sh_dossier_id,curs_row.hh_person_id,
            F_TRANSFER_INVALID_CONSTRAINT(p_sh_leistungstyp_id,curs_row.verwandtschaftsgrad_id, 'v_verwandtschaftsgrad', 'verwandtschaftsgrad_id'),
            DECODE(curs_row.b_separate_unterstuetzung, 1,1, 2,2, -9,-9, -12),
            curs_row.ahv_nr8, curs_row.ahv_nr3, curs_row.b_plausiproblem, curs_row.versichertennummer
         );


     END LOOP;

     CLOSE curs;

  END;

--******************************************************************************************************************--

  PROCEDURE SP_COPY_ROH_STDI_FEHLER(p_datenimport_id IN INTEGER, p_standort_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT soz_traeger_lieferung_id, soz_traeger_registration_id, sh_dossier_id, fehler_id, fehler_nr
  FROM roh_stdi_fehler
  WHERE soz_traeger_datenimport_id = p_datenimport_id
  AND standort_id = p_standort_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         INSERT INTO stdi_fehler (soz_traeger_lieferung_id, soz_traeger_registration_id, soz_traeger_datenimport_id, standort_id, sh_dossier_id, fehler_id, fehler_nr)
         VALUES (curs_row.soz_traeger_lieferung_id, curs_row.soz_traeger_registration_id, p_datenimport_id, p_standort_id, curs_row.sh_dossier_id, curs_row.fehler_id, curs_row.fehler_nr);

     END LOOP;

     CLOSE curs;

  END;

  --******************************************************************************************************************--

  PROCEDURE SP_COPY_STDI_FEHLER(p_datenimport_id IN INTEGER, p_standort_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT soz_traeger_lieferung_id, soz_traeger_registration_id, sh_dossier_id, fehler_id, fehler_nr
  FROM stdi_fehler
  WHERE soz_traeger_datenimport_id = p_datenimport_id
  AND standort_id = p_standort_id;

  curs_row    curs%ROWTYPE;
  nCount INTEGER;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

         SELECT count(*) INTO nCount FROM roh_sh_dossier WHERE sh_dossier_id = curs_row.sh_dossier_id;

         IF(nCount > 0) THEN

            INSERT INTO stdi_fehler (soz_traeger_lieferung_id, soz_traeger_registration_id, soz_traeger_datenimport_id, standort_id, sh_dossier_id, fehler_id, fehler_nr)
            VALUES (curs_row.soz_traeger_lieferung_id, curs_row.soz_traeger_registration_id, p_datenimport_id, p_standort_id, curs_row.sh_dossier_id, curs_row.fehler_id, curs_row.fehler_nr);

         END IF;

     END LOOP;

     CLOSE curs;

  END;

--******************************************************************************************************************--

PROCEDURE SP_COPY_STDI_FEHLER_PROBELAUF(p_datenimport_id IN INTEGER, p_standort_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT soz_traeger_lieferung_id, soz_traeger_registration_id, sh_dossier_id, fehler_id, fehler_nr
  FROM stdi_fehler
  WHERE soz_traeger_datenimport_id = p_datenimport_id
  AND standort_id = p_standort_id;

  curs_row    curs%ROWTYPE;

  BEGIN

     OPEN curs;

     LOOP

         FETCH curs INTO curs_row;

         EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

            INSERT INTO stdi_fehler_pl (soz_traeger_lieferung_id, soz_traeger_registration_id, soz_traeger_datenimport_id, standort_id, sh_dossier_id, fehler_id, fehler_nr)
            VALUES (curs_row.soz_traeger_lieferung_id, curs_row.soz_traeger_registration_id, p_datenimport_id, p_standort_id, curs_row.sh_dossier_id, curs_row.fehler_id, curs_row.fehler_nr);

     END LOOP;

     CLOSE curs;

  END;

  /*PROCEDURE SP_PLAUSIS_PRO_SELEKTION ( p_sel_id IN INTEGER)
  IS

  CURSOR curs IS
  SELECT id0 From selektion Where selektion_id = p_sel_id;

  curs_row    curs%ROWTYPE;
  BEGIN

    OPEN curs;

     LOOP

        FETCH curs INTO curs_row;

        EXIT WHEN curs%NOTFOUND OR curs%NOTFOUND IS NULL;

        DO_PLAUSI.SP_PLAUSI_100001(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100002(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100003(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100004(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100005(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100006(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100007(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100008_9(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100010(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100011(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100013(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100014(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100015(curs_row.id0);
        DO_PLAUSI.SP_PLAUSI_100016(curs_row.id0);

    END LOOP;
    CLOSE curs;

    DELETE FROM selektion Where selektion_id = p_sel_id;

  END; -- Procedure*/


  PROCEDURE SP_DN_INDIKATORTABELLE(p_tablename IN VARCHAR2)
  IS

  v_cur               INTEGER;
  v_cur2              INTEGER;
  v_rows_processed    INTEGER;
  v_count             INTEGER;
  v_create_string     VARCHAR2(100);
  v_drop_string       VARCHAR2(100);
  v_add_col           VARCHAR2(100);
  v_select_string     VARCHAR2(300);
  v_table             VARCHAR2(32);
  v_table_flach       VARCHAR2(32);
  v_alpha_code        VARCHAR2(32);

  BEGIN

    v_cur           := DBMS_SQL.OPEN_CURSOR;
    v_cur2          := DBMS_SQL.OPEN_CURSOR;

    v_count         := 0;

    v_table         := 'v_' || p_tablename;
    v_table_flach   := 'v_' || p_tablename || '_flach';
    v_drop_string   := 'DROP TABLE ' || v_table_flach;

    /* Festellen, ob die Tabelle bereits existiert */
    v_select_string := ' SELECT count(*) FROM all_tables ' ||
                       ' WHERE table_name = ''' || UPPER(v_table_flach) || '''';

    DBMS_SQL.PARSE(v_cur, v_select_string, DBMS_SQL.V7);
    DBMS_SQL.DEFINE_COLUMN(v_cur,1, v_count);

    v_rows_processed := DBMS_SQL.EXECUTE(v_cur);

    v_count := DBMS_SQL.FETCH_ROWS(v_cur);
    DBMS_SQL.COLUMN_VALUE(v_cur, 1,v_count);

    IF v_count > 0 THEN
        /* Tabelle existiert, Tabelle wird entfernt */
        DBMS_SQL.PARSE(v_cur, v_drop_string, DBMS_SQL.V7);
        v_rows_processed := DBMS_SQL.EXECUTE(v_cur);
    END IF;

    /* Alpha-Codes der Indikatoren ermitteln */
    v_select_string :=  ' SELECT alpha_code FROM ' || v_table ;

    DBMS_SQL.PARSE(v_cur, v_select_string, DBMS_SQL.V7);

    DBMS_SQL.DEFINE_COLUMN(v_cur,1, v_alpha_code, 32);

    v_rows_processed := DBMS_SQL.EXECUTE(v_cur);

    v_count := 0;

    LOOP

        IF DBMS_SQL.FETCH_ROWS(v_cur) = 0 THEN
            EXIT;
        END IF;

        DBMS_SQL.COLUMN_VALUE(v_cur, 1,v_alpha_code);

        IF v_count = 0 THEN
            /* Tabelle erstellen */
            v_create_string :=  'CREATE TABLE ' || v_table_flach ||
                                ' (' || v_alpha_code  || ' VARCHAR(32) NULL )';

            DBMS_SQL.PARSE(v_cur2, v_create_string, DBMS_SQL.V7);

            v_rows_processed := DBMS_SQL.EXECUTE(v_cur2);

        ELSE
            /* Spalten hinzufügen */
            v_add_col := 'ALTER TABLE '|| v_table_flach || ' ADD ( ' || v_alpha_code || ' VARCHAR(32) NULL)';

            DBMS_SQL.PARSE(v_cur2, v_add_col, DBMS_SQL.V7);
            v_rows_processed := DBMS_SQL.EXECUTE(v_cur2);

        END IF;

        v_count:= v_count + 1;

    END LOOP;

    DBMS_SQL.CLOSE_CURSOR(v_cur);
    DBMS_SQL.CLOSE_CURSOR(v_cur2);

  END; -- Procedure

  PROCEDURE SP_DN_INDIKATORDATEN(p_tablename IN VARCHAR2, p_key IN VARCHAR2, p_anz_keys IN INTEGER)
  IS

  v_cur               INTEGER;
  v_cur2              INTEGER;
  v_cur3              INTEGER;
  v_rows_processed    INTEGER;
  v_count             INTEGER;

  v_select_string     VARCHAR2(1000);
  v_select_string2    VARCHAR2(1000);
  v_insert_string     VARCHAR2(2000);
  v_value_string      VARCHAR2(1000);
  v_parsed_string     VARCHAR2(1000);
  v_table             VARCHAR2(32);
  v_table_flach       VARCHAR2(32);
  v_alpha_code        VARCHAR2(32);
  v_wert              VARCHAR2(32);

  v_key1              INTEGER;
  v_key2              INTEGER;
  v_key3              INTEGER;
  v_key4              INTEGER;
  v_key5              INTEGER;

BEGIN

    v_cur            := DBMS_SQL.OPEN_CURSOR;
    v_cur2           := DBMS_SQL.OPEN_CURSOR;
    v_cur3           := DBMS_SQL.OPEN_CURSOR;

    v_count          := 0;

    v_table          := 'v_' || p_tablename;
    v_table_flach    := v_table || '_flach';

    v_select_string  := ' SELECT DISTINCT ' || p_key || ' FROM ' || p_tablename;

    v_insert_string  := ' INSERT INTO ' || v_table_flach || '( ';

    v_value_string   := ' VALUES ( ';

    v_select_string2 := ' SELECT ' || v_table || '.alpha_code,' ||
                        p_tablename || '.wert FROM ' ||
                        p_tablename || ',' || v_table ||
                        ' WHERE ' || p_tablename || '.' || p_tablename || '_id = ' ||
                        v_table || '.' || p_tablename || '_id AND ';


    v_parsed_string  := F_PARSEKEYS(p_key,',',v_parsed_string);

    v_select_string2 := v_select_string2 || v_parsed_string;

    DBMS_SQL.PARSE(v_cur, v_select_string, DBMS_SQL.V7);

    DBMS_SQL.PARSE(v_cur2, v_select_string2, DBMS_SQL.V7);

    dbms_output.put_line(v_select_string2);

    IF(p_anz_keys > 5) THEN
        RETURN;
    END IF;

    IF(p_anz_keys >= 1) THEN
        DBMS_SQL.DEFINE_COLUMN(v_cur,1, v_key1);
    END IF;

    IF(p_anz_keys >= 2) THEN
        DBMS_SQL.DEFINE_COLUMN(v_cur,2, v_key2);
    END IF;

    IF(p_anz_keys >= 3) THEN
        DBMS_SQL.DEFINE_COLUMN(v_cur,3, v_key3);
    END IF;

    IF(p_anz_keys >= 4) THEN
        DBMS_SQL.DEFINE_COLUMN(v_cur,4, v_key4);
    END IF;

    IF(p_anz_keys >= 5) THEN
        DBMS_SQL.DEFINE_COLUMN(v_cur,5, v_key5);
    END IF;

    v_rows_processed := DBMS_SQL.EXECUTE(v_cur);

    DBMS_SQL.DEFINE_COLUMN(v_cur2, 1, v_alpha_code, 32);
    DBMS_SQL.DEFINE_COLUMN(v_cur2, 2, v_wert, 32);

    LOOP
        IF DBMS_SQL.FETCH_ROWS(v_cur) = 0 THEN
            EXIT;
        END IF;

        IF(p_anz_keys >= 1) THEN
            DBMS_SQL.COLUMN_VALUE(v_cur, 1, v_key1);
            DBMS_SQL.BIND_VARIABLE(v_cur2,':m1', v_key1);
        END IF;

        IF(p_anz_keys >= 2) THEN
            DBMS_SQL.COLUMN_VALUE(v_cur, 2, v_key2);
            DBMS_SQL.BIND_VARIABLE(v_cur2,':m2', v_key2);
        END IF;

        IF(p_anz_keys >= 3) THEN
            DBMS_SQL.COLUMN_VALUE(v_cur, 3, v_key3);
            DBMS_SQL.BIND_VARIABLE(v_cur2,':m3', v_key3);
        END IF;

        IF(p_anz_keys >= 4) THEN
            DBMS_SQL.COLUMN_VALUE(v_cur, 4, v_key4);
            DBMS_SQL.BIND_VARIABLE(v_cur2,':m4', v_key4);
        END IF;

        IF(p_anz_keys >= 5) THEN
            DBMS_SQL.COLUMN_VALUE(v_cur, 5, v_key5);
            DBMS_SQL.BIND_VARIABLE(v_cur2,':m5', v_key5);
        END IF;

        v_rows_processed := DBMS_SQL.EXECUTE(v_cur2);

        v_count := 0;

        LOOP
            IF DBMS_SQL.FETCH_ROWS(v_cur2) = 0 THEN
                EXIT;
            END IF;

            DBMS_SQL.COLUMN_VALUE(v_cur2, 1, v_alpha_code);
            DBMS_SQL.COLUMN_VALUE(v_cur2, 2, v_wert);

            v_insert_string := v_insert_string || v_alpha_code || ',';

            IF v_wert IS NULL THEN
                v_wert := ' NULL ';
            END IF;

            v_value_string  := v_value_string || '''' || v_wert || ''',';

            v_count := v_count + 1;

        END LOOP;

        IF v_count  > 0 THEN
            v_insert_string := SUBSTR(v_insert_string,1,LENGTH(v_insert_string)-1);
            v_value_string  := SUBSTR(v_value_string,1,LENGTH(v_value_string)-1);
            v_insert_string := v_insert_string || ')';
            v_value_string  := v_value_string || ')';
            v_insert_string := v_insert_string || v_value_string;

            DBMS_SQL.PARSE(v_cur3, v_insert_string, DBMS_SQL.V7);
            v_rows_processed := DBMS_SQL.EXECUTE(v_cur3);
            COMMIT;
        END IF;

    END LOOP;

    DBMS_SQL.CLOSE_CURSOR(v_cur);
    DBMS_SQL.CLOSE_CURSOR(v_cur2);
    DBMS_SQL.CLOSE_CURSOR(v_cur3);

  END; --Procedure

FUNCTION F_ParseKeys(sStr IN VARCHAR2, cSeparator IN CHAR , strParsed IN OUT VARCHAR2)
  RETURN VARCHAR2
  IS
     iStrLength INTEGER      := LENGTH(sStr);
     sStrVal VARCHAR2(50)    := '';
     cChar CHAR(1)           := '';
     nKeyId NUMBER           := 0;
     nPos   INTEGER          := 1;
     nCount INTEGER          := 1;

  BEGIN
     IF iStrLength = 0 THEN
       RETURN '';
     END IF;

     strParsed  := ' ';

     cChar := SUBSTR(sStr,1,1);

     WHILE (nPos < iStrLength) LOOP

        WHILE (cChar<>cSeparator AND nPos <= iStrLength) LOOP
          sStrVal := CONCAT(sStrVal,cChar);
          nPos := nPos + 1;
          cChar := SUBSTR(sStr,nPos,1);
        END LOOP;

        strParsed := strParsed || sStrVal || ' = :m' || TO_CHAR(nCount);
        sStrVal := '';

        IF(nPos < iStrLength) THEN
            strParsed := strParsed || ' AND ';
            nPos      := nPos + 1;
            cChar     := SUBSTR(sStr,nPos,1);
        END IF;

        nCount := nCount + 1;
     END LOOP;

     RETURN strParsed;

   END; -- F_ParseKeys;

PROCEDURE SP_HAUSHALTSTYP(p_haushalt_id IN INTEGER)
IS
nWohnsituationId sh_haushalt.sh_wohnsituation_id%TYPE;
BEGIN
    SELECT sh_wohnsituation_id INTO nWohnsituationid
    FROM sh_haushalt WHERE sh_haushalt.sh_haushalt_id = p_haushalt_id;

    IF nWohnsituationid IN (4, 5, 6, 7, 8) THEN
--        UPDATE sh_haushalt
--        SET sh_haushaltstyp_id = 0 -- Kollektivhaushalt
--        WHERE sh_haushalt.sh_haushalt_id = p_haushalt_id;
        NULL;
    ELSIF nWohnsituationid IN (1, 2, 3) THEN
--        UPDATE sh_haushalt
--        SET sh_haushaltstyp_id = 1 -- Kollektivhaushalt
--        WHERE sh_haushalt.sh_haushalt_id = p_haushalt_id;
        NULL;
    END IF;
END; -- SP_HAUSHALTSTYP

PROCEDURE SP_TEST
IS
BEGIN

    SP_DN_INDIKATORTABELLE('kanton_indikator');
    SP_DN_INDIKATORDATEN('kanton_indikator', 'kanton_indikator.kanton_id, kanton_indikator.jahr ' , 2);
END;

/* --------------------------------------------------------------------------
   ISOS 4.2
   ********
   Version 1.00   10.09.2008   Oliver Heiler, Concevis AG
   Grund:         Historisierungsfelder "erstellt_dat", "erstellt_user" hinzugefügt

   ISOS 6.0
   ********
   Version 1.00   22.09.2010   Oliver Heiler, Concevis AG
   Grund:         Neues Feld Lieferfrist
* -------------------------------------------------------------------------- */

FUNCTION F_GEN_SOZ_TRAEGER_LIEFERUNG(p_kanton_id IN INTEGER, p_jahr IN INTEGER, p_user_id INTEGER)
RETURN INTEGER
IS
    l_sql_insert        VARCHAR2(4000) := NULL;
    nStandortId         INTEGER;
    nShTraegerId        INTEGER;
    nDienstNrVon        INTEGER;
    nDienstNrBis        INTEGER;
    nNewId              INTEGER;
    nLieferFrist        VARCHAR2(6);

    CURSOR DienstZust IS

        SELECT DISTINCT s.sozialleistungstraeger_id FROM sozialleistungstraeger s, v_sh_zustaendigkeit sz
        WHERE s.sozialleistungstraeger_id >= nDienstNrVon
        AND s.sozialleistungstraeger_id <= nDienstNrBis
        AND s.sozialleistungstraeger_id = sz.sozialleistungstraeger_id
        AND (   SELECT count(*) FROM v_sh_zustaendigkeit
                WHERE sozialleistungstraeger_id = s.sozialleistungstraeger_id
                AND TO_NUMBER(TO_CHAR(dat_bis, 'YYYY')) >= p_jahr
                AND TO_NUMBER(TO_CHAR(dat_von, 'YYYY')) <= p_jahr
                OR (dat_von IS NULL AND dat_bis IS NULL)
                OR (TO_NUMBER(to_char(dat_von, 'YYYY')) <= p_jahr AND dat_bis IS NULL)
                OR (dat_von IS NULL AND TO_NUMBER(to_char(dat_bis, 'YYYY')) >= p_jahr)
                AND sh_leistungstyp_id > 0
            ) > 0;


    curs DienstZust%ROWTYPE;

BEGIN

SELECT standort_id INTO nStandortId FROM v_user WHERE user_id = p_user_id;

SELECT dienst_nr_von, dienst_nr_bis INTO nDienstNrVon, nDienstNrBis
FROM standort_kanton
WHERE standort_id = nStandortId AND kanton_id = p_kanton_id;

SELECT lieferfrist INTO nLieferFrist FROM v_kanton WHERE kanton_id = p_kanton_id;

FOR curs IN DienstZust
    LOOP
        SELECT NVL(MAX(soz_traeger_lieferung_id)+ 1,1) INTO nNewId FROM soz_traeger_lieferung;

      l_sql_insert := 'INSERT INTO soz_traeger_lieferung
                                (soz_traeger_lieferung_id, standort_id,
                                 sozialleistungstraeger_id, jahr, kanton_id,
                                 lieferstatus_id, erstellt_dat, erstellt_user, lieferfrist)
                      VALUES ( ' || nNewId || ',' || nStandortId || ','
                                 || curs.sozialleistungstraeger_id || ',' || p_jahr || ',' || p_kanton_id || ',1, SYSDATE,' || p_user_id || ', TO_DATE(''' || nLieferFrist || TO_CHAR(p_jahr+1) || ''', ''DD.MM.YYYY''' || '))';

      EXECUTE IMMEDIATE l_sql_insert;

      COMMIT;
      -- Liefererwartungen erzeugen
      SP_INSERT_LIEFERERWARTUNG(nNewId, nStandortId, p_sozialleistungstraeger_id => curs.sozialleistungstraeger_id, p_jahr => p_jahr);
    END LOOP;

   RETURN 0;
END; -- SP_GENERATE_SOZ_TRAEGER_LIEFERUNG

PROCEDURE SP_INSERT_LIEFERERWARTUNG(p_liefer_id INTEGER, p_standort_id INTEGER, p_sozialleistungstraeger_id INTEGER, p_jahr INTEGER)
IS
l_sql_insert        VARCHAR2(4000) := NULL;
nNewID             INTEGER;
nLieferID           INTEGER;
cnt                 INTEGER;
nAnzDossiers        INTEGER := 0;
nAnzAnfang          INTEGER := 0;
nAnzStichtag        INTEGER := 0;
nAnzPersAnfang      INTEGER := 0;
nAnzPersStichtag    INTEGER := 0;

BEGIN

   FOR x IN (

        SELECT sozialleistungstraeger_id, gemeinde_id, sh_leistungstyp_id
        FROM v_sh_zustaendigkeit WHERE sozialleistungstraeger_id = p_sozialleistungstraeger_id
        AND TO_NUMBER(TO_CHAR(dat_von, 'YYYY')) <= p_jahr
        AND TO_NUMBER(TO_CHAR(dat_bis, 'YYYY')) >= p_jahr
        AND sh_leistungstyp_id > 0
        OR (dat_von IS NULL AND dat_bis IS NULL AND sozialleistungstraeger_id = p_sozialleistungstraeger_id)
        OR (TO_NUMBER(to_char(dat_von, 'YYYY')) <= p_jahr AND dat_bis IS NULL AND sozialleistungstraeger_id = p_sozialleistungstraeger_id)
        OR (dat_von IS NULL AND TO_NUMBER(to_char(dat_bis, 'YYYY')) >= p_jahr AND sozialleistungstraeger_id = p_sozialleistungstraeger_id)

   ) LOOP

      BEGIN

      SELECT soz_traeger_lieferung_id INTO nLieferID
      FROM soz_traeger_lieferung
      WHERE sozialleistungstraeger_id = p_sozialleistungstraeger_id
      AND jahr = p_jahr-1;

         SELECT
         NVL((
         SELECT COUNT(sh_dossier_id)
         FROM roh_sh_dossier
         WHERE soz_traeger_lieferung_id = nLieferID and standort_id = p_standort_id
          AND roh_sh_dossier.gemeinde_id = x.gemeinde_id
          AND roh_sh_dossier.sozialleistungstraeger_id = x.sozialleistungstraeger_id
          AND roh_sh_dossier.sh_leistungstyp_id = x.sh_leistungstyp_id
         ),0  ) as anz_dossiers,
         NVL((
         SELECT COUNT(sh_dossier_id)
         FROM roh_sh_dossier
         WHERE roh_sh_dossier.b_neubezuegerrecord = 0 AND soz_traeger_lieferung_id = nLieferID and standort_id = p_standort_id
           AND roh_sh_dossier.gemeinde_id = x.gemeinde_id
          AND roh_sh_dossier.sozialleistungstraeger_id = x.sozialleistungstraeger_id
          AND roh_sh_dossier.sh_leistungstyp_id = x.sh_leistungstyp_id
         ),0  ) as anz_dossiers_anfang,
         NVL((
          SELECT sum(anz_personen_ue)
          FROM roh_sh_dossier
          WHERE roh_sh_dossier.b_neubezuegerrecord = 0 AND soz_traeger_lieferung_id = nLieferID and standort_id = p_standort_id
          AND roh_sh_dossier.gemeinde_id = x.gemeinde_id
          AND roh_sh_dossier.sozialleistungstraeger_id = x.sozialleistungstraeger_id
          AND roh_sh_dossier.sh_leistungstyp_id = x.sh_leistungstyp_id
         ),0)  as anz_personen_ue_anfang,
         NVL((
          SELECT COUNT(sh_dossier_id)
          FROM roh_sh_dossier
          WHERE roh_sh_dossier.b_neubezuegerrecord = 1 AND soz_traeger_lieferung_id = nLieferID and standort_id = p_standort_id
          AND roh_sh_dossier.gemeinde_id = x.gemeinde_id
          AND roh_sh_dossier.sozialleistungstraeger_id = x.sozialleistungstraeger_id
          AND roh_sh_dossier.sh_leistungstyp_id = x.sh_leistungstyp_id
         ),0)  as anz_dossiers_stichtag,
         NVL((
          SELECT sum(anz_personen_ue)
          FROM roh_sh_dossier
          WHERE roh_sh_dossier.b_neubezuegerrecord = 1 AND soz_traeger_lieferung_id = nLieferID and standort_id = p_standort_id
           AND roh_sh_dossier.gemeinde_id = x.gemeinde_id
          AND roh_sh_dossier.sozialleistungstraeger_id = x.sozialleistungstraeger_id
          AND roh_sh_dossier.sh_leistungstyp_id = x.sh_leistungstyp_id
         ),0)  as anz_personen_ue_stichtag
         INTO nAnzDossiers, nAnzAnfang, nAnzPersAnfang, nAnzStichtag, nAnzPersStichtag
         FROM DUAL;

        EXCEPTION
         WHEN NO_DATA_FOUND THEN
         DBMS_OUTPUT.PUT_LINE('');
       END;

      SELECT NVL(MAX(soz_traeger_liefererwartung_id)+ 1,1) INTO nNewId FROM soz_traeger_liefererwartung;

      l_sql_insert := 'INSERT INTO soz_traeger_liefererwartung
                                (soz_traeger_liefererwartung_id, soz_traeger_lieferung_id, standort_id,
                                 sozialleistungstraeger_id, gemeinde_id, sh_leistungstyp_id,
                                 anz_dossiers, anz_anfang, anz_stichtag, anz_pers_anfang, anz_pers_stichtag)
                      VALUES ( ' || nNewId || ',' || p_liefer_id || ',' || p_standort_id || ',' ||
                                    x.sozialleistungstraeger_id || ',' || x.gemeinde_id || ',' || x.sh_leistungstyp_id || ',' ||
                                    nAnzDossiers || ',' || nAnzAnfang || ',' || nAnzStichtag || ',' ||
                                    nAnzPersAnfang || ',' || nAnzPersStichtag || ')';

      EXECUTE IMMEDIATE l_sql_insert;

      COMMIT;

   END LOOP;

    /*SELECT count(*) INTO cnt FROM soz_traeger_lieferung
    WHERE   standort_id = p_standort_id
    AND sozialleistungstraeger_id = p_sozialleistungstraeger_id
    AND jahr = p_jahr-1;

    IF (cnt > 0) THEN

        SELECT NVL(soz_traeger_lieferung_id,-9999) INTO nLieferID
        FROM soz_traeger_lieferung
        WHERE standort_id = p_standort_id
        AND sozialleistungstraeger_id = p_sozialleistungstraeger_id
        AND jahr = p_jahr-1;

         -- Werte aus dem letzen Jahr kopieren
        SP_COPY_LIEFERERWARTUNG(p_liefer_id, nLieferID, p_standort_id, p_sozialleistungstraeger_id, p_jahr);

   END IF;*/
END;

PROCEDURE SP_COPY_LIEFERERWARTUNG ( p_new_id INTEGER , p_prev_liefer_id INTEGER, p_standort_id INTEGER, p_sozialleistungstraeger_id INTEGER, p_jahr INTEGER)
IS
    l_sql_update        VARCHAR2(4000) := NULL;

BEGIN
    FOR x IN (

        SELECT soz_traeger_liefererwartung.sozialleistungstraeger_id, gemeinde_id, sh_leistungstyp_id, NVL(anz_dossiers,0) as anz_dossiers, NVL(anz_anfang,0) as anz_anfang, NVL(anz_stichtag,0) as anz_stichtag,
        NVL(anz_pers_anfang,0) as pers_anfang, NVL(anz_pers_stichtag,0) as pers_stichtag
        FROM soz_traeger_liefererwartung, soz_traeger_lieferung
        WHERE soz_traeger_liefererwartung.standort_id = p_standort_id
        AND soz_traeger_lieferung.standort_id = soz_traeger_liefererwartung.standort_id
        AND soz_traeger_liefererwartung.soz_traeger_lieferung_id = soz_traeger_lieferung.soz_traeger_lieferung_id
        AND soz_traeger_lieferung.soz_traeger_lieferung_id = p_prev_liefer_id

   ) LOOP

      l_sql_update :=   'UPDATE soz_traeger_liefererwartung SET
                        anz_dossiers = ' || x.anz_dossiers ||
                        ', anz_anfang = ' || x.anz_anfang  ||
                        ', anz_stichtag = ' || x.anz_stichtag ||
                        ', anz_pers_anfang =  ' || x.pers_anfang ||
                        ', anz_pers_stichtag =  ' || x.pers_stichtag ||
                        ' WHERE gemeinde_id = ' || x.gemeinde_id ||
                        ' AND sh_leistungstyp_id = ' || x.sh_leistungstyp_id ||
                        ' AND sozialleistungstraeger_id = ' || x.sozialleistungstraeger_id ||
                        ' AND standort_id = ' || p_standort_id ||
                        ' AND soz_traeger_lieferung_id = ' || p_new_id;

      EXECUTE IMMEDIATE l_sql_update;
      COMMIT;
    END LOOP;
END;

FUNCTION F_TRANSFER_MISSING_AHV_NR(p_ahv_nr IN VARCHAR2)
RETURN VARCHAR2
IS
BEGIN
     IF p_ahv_nr IN (C_AHV_MISSING_CHIFFRE) THEN
       RETURN '-12';
     END IF;

RETURN p_ahv_nr;
END;

FUNCTION F_TRANSFER_INVALID_JAHR(p_jahr IN INTEGER, p_jahr_ep_in IN INTEGER)
RETURN  INTEGER
IS
BEGIN
    IF (p_jahr = -9 OR p_jahr = -6 OR p_jahr = -1 OR p_jahr = -3 OR p_jahr = -5
        OR p_jahr = -8 OR p_jahr = -62 OR p_jahr = 63 OR p_jahr = -65 OR p_jahr = -68) THEN
        return p_jahr;
    ELSIF
        (p_jahr <= p_jahr_ep_in-120)
        OR (p_jahr BETWEEN p_jahr_ep_in+2 AND 9998 ) THEN
        return -12;
    END IF;

    RETURN p_jahr;

END;

END;
/

create or replace 
PACKAGE BODY do_flustat
IS

/* --------------------------------------------------------------------------
   ISOS 6.1
   ********
   Version 1.00   01.02.2011   Oliver Heiler, Concevis AG
   Grund:         Abgleich Aufenthaltsstatus mit Finasi-Tabelle für Antragsteller,
                  UE-Personen für die angegebene Dossier-ID
   Version 1.01   24.02.2011 Oliver Heiler, Concevis AG
                  Abgleich Aufenthaltstatus bzw. Nationalität erfolgt nur über
                  gefundene Einträge über Versichertennummer
                  Sonst nur Eintrag in Finasi-Log
                  Neue Regel beim Abgleich Aufenthaltsstatus:
                  dat_statuswechsel = leer => bfm_status_letzt_in_ep
                  dat_statuswechsel = gefüllt => bfm_status_erst_in_ep
                  Wenn Nationalität leer => Abgleich mit Nationalität aus Finasi
    ISOS 6.2
   ********
   Version 1.1   04.10.2011 Oliver Heiler, Concevis AG
                  Abgleich nur für Dossies mit Leistungstyp 1-5
                  Abgleich über Paket 1 (demo1) entfällt
                  Abgleich nur noch über Antragsteller, kein Abgleich über für
                  UE-Personen
                  FC_FLUSTAT_GRUNDGESAMTHEIT hinzugefügt (Berechnung der Merkmale
                  ggfstat, ggfstatue, mispers und misdoss

    Version 1.2   23.01.2012 Oliver Heiler, Concevis AG
                  SP_UPDATE_AUFENTHALTSSTATUS Prozess Wiederholung


    ISOS 6.3
    ***********
    Version 1.3  18.10.2012 Oliver Heiler, Concevis AG
                 Nur noch Status bfm_status_letzt_in_ep  berücksichtigen, statt
                 Unterscheidung dat_statuswechsel => bfm_status_erst_in_ep oder bfm_status_letzt_in_ep

    Version 1.4  12.12.2012 Oliver, Heiler, Concevis AG
                 Wenn Datum der letzten Zahlung < Statuswechsel => Aufenthaltstatus = bfm_status_erst_in_ep
                 Sonst Aufenthaltstatus = l_bfm_status_letzt_in_ep

    Version 1.4.1 13.02.2013 Stéphane Graniger, OFS
                  Anpassung für Abgeschlossene Dossiers
                  Wenn der Dossier Abgeschlossen ist (dat_letzte_zahlung zwischen 01.07.EP-1 und 31.12.EP-1 et b_bezug_stichtag = 2 ) machen wir keine Abgleich
                  Si le dossier est clos (dat_letzte_zahlung entre 01.07.EP-1 et 31.12.EP-1 et b_bezug_stichtag = 2 ) l'abgleich n'est pas nécessaire

    Version 1.5  11.03.2013 Oliver Heiler, Concevis AG
                 Neue Funktion FC_FLUSTAT_COPY_CHECK eingefügt. Prüft, ob es für ein kopiertes Dossier (Flustat-Kopie) doch einen richtigen Kandidaten aus
                 einer anderen Lieferung gibt.
    
    ISOS 6.4
    ***********
    Version 1.6  03.10.2013 Oliver Heiler, Concevis AG
                 Anpassung SP_UPDATE_AUFENTHALTSSTATUS, Abgleich über Versichertennummer erfolgt auch, wenn mehrere Zeilen für die Versichertennummer gefunden werden 
                 und Gemeinde und Status aber übereinstimmen
                 Bei Wiederholung wird ein neuer Finasi-Eintrag erzeugt, der bestehende Eintrag mit b_wiederholung = 0 wird nicht verändert.
                 
    Version 1.7  21.03.2013 Oliver Heiler, Concevis AG
                 Neue SP_COPY_FLUSTAT_DOSSIERS, SP_COPY_FLUSSTAT_DOSSIER kopiert Dossiers mit 6 Monate Regel aus den Primärdaten in die Sekundärdaten
                 
* -------------------------------------------------------------------------- */

PROCEDURE SP_UPDATE_AUFENTHALTSSTATUS ( p_sh_dossier_id sh_dossier.sh_dossier_id%TYPE, p_wiederholung INTEGER )
IS

l_bfm_status_erst_in_ep finasi.bfm_status_erst_in_ep%TYPE;
l_bfm_status_letzt_in_ep finasi.bfm_status_letzt_in_ep%TYPE;
l_bfm_status INTEGER;
l_jahr finasi.jahr%TYPE;
l_symic_nr finasi.symic_nr%TYPE;
l_doss_nr finasi.dos_nr%TYPE;
l_pers_nr finasi.pers_nr%TYPE;
l_finasi_nationalitaet finasi.nationalitaet%TYPE;
l_dat_statuswechsel finasi.dat_statuswechsel%TYPE;
l_dat_geburt antragsteller.dat_geburt%TYPE;
l_in_ch_seit antragsteller.in_ch_seit_jahr%TYPE;
l_nationalitaet_land_id antragsteller.nationalitaet_land_id%TYPE;
l_geschlecht_id antragsteller.geschlecht_id%TYPE;
l_zvr_plz antragsteller.zvr_plz%TYPE;
l_aufenthaltsstatus_id antragsteller.aufenthaltsstatus_id%TYPE;
l_prim_aufenthaltsstatus_id antragsteller.aufenthaltsstatus_id%TYPE;
l_aufenthaltsstatus_id_alt antragsteller.aufenthaltsstatus_id%TYPE;
l_roh_aufenthaltsstatus_id_alt roh_antragsteller.aufenthaltsstatus_id%TYPE;
l_dat_letzte_zahlung sh_dossier.dat_letzte_zahlung%TYPE;
l_geburtsjahr ue_person.geburtsjahr%TYPE;
l_ue_person_id ue_person.ue_person_id%TYPE;
l_versichertennummer antragsteller.versichertennummer%TYPE;
l_gemeinde_id sh_dossier.gemeinde_id%TYPE;
l_cnt INTEGER;
l_dublette_id finasi_log.dublette_id%TYPE;
l_dubletten_count INTEGER;
l_finasi_log_id INTEGER;
l_leistungstyp_id INTEGER;
l_record_exists NUMBER;
l_fin_log_aufentstatus_neu_id INTEGER;
l_dat_letzte_zahlung2 sh_dossier.dat_letzte_zahlung%TYPE; -- AJOUT STG
l_b_bezug_stichtag INTEGER; -- AJOUT STG
l_jahrEP INTEGER; -- AJOUT STG
l_vers_seq INTEGER;
l_gem_seq INTEGER;
l_bfm_erst_in_ep_seq INTEGER;
l_bfm_letzt_in_ep_seq INTEGER;
l_result INTEGER;

BEGIN
    l_cnt := 0;


    -- Nur Dossiers mit WSH (Leistungstyp 1-5) werden abgeglichen
    SELECT sh_leistungstyp_id INTO l_leistungstyp_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id;

    if l_leistungstyp_id NOT IN (1,2,3,4,5) THEN
        RETURN;
    END IF;

     -- AJOUT STG Seulement les dossiers pas clos (ouverts) sont comparés
    SELECT dat_letzte_zahlung, b_bezug_stichtag, jahr  INTO l_dat_letzte_zahlung2, l_b_bezug_stichtag, l_jahrEP FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id;

    if  (l_dat_letzte_zahlung2 BETWEEN TO_DATE('01.07.' || to_char(l_jahrEP-1), 'DD.MM.YYYY') AND TO_DATE('31.12.' || to_char(l_jahrEP-1), 'DD.MM.YYYY')) AND l_b_bezug_stichtag = 2 THEN
        RETURN;
    END IF;
    -- FIN AJOUT STG

    SELECT sh_dossier.dat_letzte_zahlung, dat_geburt, in_ch_seit_jahr, nationalitaet_land_id, geschlecht_id, zvr_plz, aufenthaltsstatus_id, versichertennummer, gemeinde_id, sh_dossier.jahr
    INTO l_dat_letzte_zahlung, l_dat_geburt, l_in_ch_seit, l_nationalitaet_land_id, l_geschlecht_id, l_zvr_plz, l_prim_aufenthaltsstatus_id, l_versichertennummer, l_gemeinde_id, l_jahr
    FROM antragsteller
    INNER JOIN sh_dossier ON (antragsteller.sh_dossier_id = sh_dossier.sh_dossier_id)
    WHERE antragsteller.sh_dossier_id = p_sh_dossier_id;

    SELECT COUNT(*) INTO l_cnt FROM roh_antragsteller
    WHERE roh_antragsteller.sh_dossier_id = p_sh_dossier_id;

    IF l_cnt = 1 THEN

        SELECT aufenthaltsstatus_id INTO l_roh_aufenthaltsstatus_id_alt FROM roh_antragsteller
        WHERE roh_antragsteller.sh_dossier_id = p_sh_dossier_id;
    ELSE
        l_roh_aufenthaltsstatus_id_alt := -9;
    END IF;

    l_cnt := 0;
    l_dubletten_count := 1;
    l_aufenthaltsstatus_id := NULL;

    IF l_nationalitaet_land_id <> 131 THEN
    BEGIN

      -- Dubletteneinträge berücksichtigen, wenn kein Gemeindewechsel 
      -- vorliegt und auch die Stati gleich sind, können wir über Versichertennummmer abgleichen.
      -- Liegt eine Gemeindewechsel vor bzw. unterscheiden sich Status erst_in_ep bzw. letzt_in_ep
      -- wissen wir nicht, welchen Stati wir nehmen müssen => Vorschlag über Demo
      BEGIN
        SELECT MAX(vers_seq), MAX(gem_seq), MAX(bfm_erst_in_ep_seq), MAX(bfm_letzt_in_ep_seq)
        INTO l_vers_seq, l_gem_seq, l_bfm_erst_in_ep_seq, l_bfm_letzt_in_ep_seq
        FROM
        (
          SELECT 
          COUNT(*) OVER (PARTITION BY finasi.versichertennummer) vers_seq, 
          COUNT(*) OVER (PARTITION BY finasi.gemeinde_id) gem_seq,
          COUNT(*) OVER (PARTITION BY finasi.bfm_status_erst_in_ep) bfm_erst_in_ep_seq,
          COUNT(*) OVER (PARTITION BY finasi.bfm_status_letzt_in_ep) bfm_letzt_in_ep_seq
          FROM finasi
          WHERE finasi.jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
          AND versichertennummer = l_versichertennummer
        );
       
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_vers_seq := 0;
      END;
      
      IF  l_vers_seq = 1 OR (l_vers_seq = l_gem_seq AND l_vers_seq = l_bfm_erst_in_ep_seq AND l_vers_seq = l_bfm_letzt_in_ep_seq) THEN -- IF 1
      BEGIN -- BEGIN IF 1

            -- Abgleich über Versichertennummer
            SELECT NVL(bfm_status_erst_in_ep,-9), NVL(bfm_status_letzt_in_ep, -9), finasi.jahr, finasi.symic_nr, finasi.dos_nr, finasi.pers_nr, finasi.dat_statuswechsel, finasi.nationalitaet
            INTO l_bfm_status_erst_in_ep, l_bfm_status_letzt_in_ep, l_jahr, l_symic_nr, l_doss_nr, l_pers_nr, l_dat_statuswechsel, l_finasi_nationalitaet
            FROM finasi
            WHERE finasi.jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
            AND versichertennummer = l_versichertennummer
            AND ROWNUM = 1;

            -- Regeln:
            -- Wenn Datum der letzten Zahlung < Statuswechsel => Aufenthaltstatus = bfm_status_erst_in_ep
            -- Sonst Aufenthaltstatus = l_bfm_status_letzt_in_ep
            IF  l_dat_letzte_zahlung < l_dat_statuswechsel THEN
                l_bfm_status := l_bfm_status_erst_in_ep;
            ELSE
                l_bfm_status := l_bfm_status_letzt_in_ep;
            END IF;

            SELECT COUNT(*) INTO l_cnt  FROM v_aufenthaltsstatus WHERE bfm_code = l_bfm_status;

            IF l_cnt > 0 THEN
                SELECT aufenthaltsstatus_id INTO l_aufenthaltsstatus_id FROM v_aufenthaltsstatus WHERE bfm_code = l_bfm_status;
            END IF;

            IF l_aufenthaltsstatus_id is null AND l_bfm_status IN (1,2,3) THEN
                l_aufenthaltsstatus_id := 7;
            END IF;

            IF l_aufenthaltsstatus_id IS NULL THEN
                l_aufenthaltsstatus_id := l_prim_aufenthaltsstatus_id;
            END IF;

            IF p_wiederholung = 0 THEN
                 UPDATE antragsteller SET aufenthaltsstatus_id = l_aufenthaltsstatus_id WHERE sh_dossier_id = p_sh_dossier_id;
            END IF;

            l_finasi_log_id := NULL;

            IF p_wiederholung = 1 THEN
                l_result := FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id,  l_jahr, l_symic_nr, l_doss_nr, l_pers_nr,  NULL, l_roh_aufenthaltsstatus_id_alt, l_prim_aufenthaltsstatus_id, 1);
            ELSE -- IF p_wiederholung = 1
              
                SELECT SQ_FINASILOG_ID.NEXTVAL
                INTO l_finasi_log_id
                FROM DUAL;

                INSERT INTO finasi_log (finasi_log_id, jahr, symic_nr, dos_nr, pers_nr, sh_dossier_id, aufenthaltsstatus_id_alt, aufenthaltsstatus_id_neu, b_wiederholung, finasi_abgleich_status_id, b_erledigt, dat_erledigt)
                VALUES (l_finasi_log_id, l_jahr, l_symic_nr, l_doss_nr, l_pers_nr, p_sh_dossier_id, l_roh_aufenthaltsstatus_id_alt, l_aufenthaltsstatus_id, 0, 1, 1, SYSDATE);

            END IF;
        END; -- BEGIN IF 1
        ELSE
           BEGIN

                -- Abgleich Paket 2, Geburtsdatum (V4.01), Geschlecht (V4.02), Nationalität (V4.04), Gemeinde-Nr (V1.01)
                SELECT COUNT(*) INTO l_cnt
                FROM finasi
                WHERE jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                AND finasi.gebdat = l_dat_geburt
                AND (SELECT DISTINCT land_id FROM v_land WHERE bfm_land_code = finasi.nationalitaet) = l_nationalitaet_land_id
                AND CASE finasi.geschlecht WHEN 'M' THEN 1 WHEN 'F' THEN 2 ELSE -9 END = l_geschlecht_id
                AND finasi.gemeinde_id = l_gemeinde_id;

                IF l_cnt > 0 THEN
                BEGIN
                    FOR x IN
                    (
                        SELECT NVL(bfm_status_letzt_in_ep,-9) as bfm_status_letzt_in_ep, finasi.jahr, finasi.symic_nr, finasi.dos_nr, finasi.pers_nr
                        FROM finasi
                        WHERE jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                        AND finasi.gebdat = l_dat_geburt
                        AND (SELECT DISTINCT land_id FROM v_land WHERE bfm_land_code = finasi.nationalitaet) = l_nationalitaet_land_id
                        AND CASE finasi.geschlecht WHEN 'M' THEN 1 WHEN 'F' THEN 2 ELSE -9 END = l_geschlecht_id
                        AND finasi.gemeinde_id = l_gemeinde_id
                    )
                    LOOP
                        IF p_wiederholung = 1 THEN
                            l_result := FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id,  x.jahr, x.symic_nr, x.dos_nr, x.pers_nr,  NULL, l_roh_aufenthaltsstatus_id_alt, l_prim_aufenthaltsstatus_id, 3);
                        ELSE -- IF p_wiederholung = 1
                            SELECT SQ_FINASILOG_ID.NEXTVAL
                            INTO l_finasi_log_id
                            FROM DUAL;

                            INSERT INTO finasi_log (finasi_log_id, jahr, symic_nr, dos_nr, pers_nr, sh_dossier_id, aufenthaltsstatus_id_alt, aufenthaltsstatus_id_neu, finasi_abgleich_status_id, dublette_id, b_wiederholung)
                            VALUES (l_finasi_log_id, x.jahr, x.symic_nr, x.dos_nr, x.pers_nr, p_sh_dossier_id, l_roh_aufenthaltsstatus_id_alt, l_prim_aufenthaltsstatus_id, 3, l_dublette_id, 0);

                            UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
                            WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                            AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);

                         END IF;
                        
                         IF l_dubletten_count = 1 THEN
                            l_dublette_id := x.pers_nr;
                         END IF;

                         l_dubletten_count := l_dubletten_count + 1;
                    END LOOP;
                END;
                ELSE
                    -- Kein Treffer für das Dossier in FINASI, wenn Nationalitaet des Antragstellers = Ausländer und Aufenthaltsstatus = 14,15, dann Eintrag in FINASI-LOG mit nicht gefunden
                    IF (l_nationalitaet_land_id > 0 OR l_nationalitaet_land_id = -1) AND l_nationalitaet_land_id <> 131 THEN
                        BEGIN
                          IF p_wiederholung = 1 THEN
                              l_result := FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id,  l_jahr, NULL, NULL, NULL, NULL, l_roh_aufenthaltsstatus_id_alt, l_prim_aufenthaltsstatus_id, 4);
                          ELSE
                            IF l_prim_aufenthaltsstatus_id IN (-1,7,14,15) THEN
                            
                              SELECT SQ_FINASILOG_ID.NEXTVAL
                              INTO l_finasi_log_id
                              FROM DUAL;

                              INSERT INTO finasi_log (finasi_log_id, jahr, symic_nr, dos_nr, pers_nr, sh_dossier_id, aufenthaltsstatus_id_alt, aufenthaltsstatus_id_neu, finasi_abgleich_status_id, b_wiederholung)
                              VALUES (l_finasi_log_id, l_jahr, NULL, NULL, NULL, p_sh_dossier_id, l_roh_aufenthaltsstatus_id_alt, l_prim_aufenthaltsstatus_id, 4,0);

                              UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
                              WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                              AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);
                            END IF;
                          END IF;
                        END;
                    END IF;
                END IF;
            END;
            END IF;
       -- END;
        --END IF;
    END;
    END IF;

    -- Abgleich UE-Personen, nur über Versichertennummer
    l_dubletten_count := 1;
    l_finasi_log_id := NULL;

    FOR x IN
    (
        SELECT ue_person_id, geburtsjahr, in_ch_seit_jahr, nationalitaet_land_id, aufenthaltsstatus_id, geschlecht_id, versichertennummer
        FROM ue_person
        WHERE sh_dossier_id = p_sh_dossier_id
        AND nationalitaet_land_id <> 131
    )
    LOOP

        l_cnt := 0;
        l_finasi_log_id := NULL;
        l_aufenthaltsstatus_id := NULL;
           
        BEGIN
          SELECT aufenthaltsstatus_id INTO l_roh_aufenthaltsstatus_id_alt FROM roh_ue_person WHERE sh_dossier_id = p_sh_dossier_id AND roh_ue_person.ue_person_id = x.ue_person_id;
          
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_roh_aufenthaltsstatus_id_alt := -9;
        END;
            
      -- Dubletteneinträge berücksichtigen, wenn kein Gemeindewechsel 
      -- vorliegt und auch die Stati gleich sind, können wir über Versichertennummmer abgleichen.
      -- Liegt eine Gemeindewechsel vor bzw. unterscheiden sich Status erst_in_ep bzw. letzt_in_ep
      -- wissen wir nicht, welchen Stati wir nehmen müssen => Vorschlag über Demo
        BEGIN
          SELECT MAX(vers_seq), MAX(gem_seq), MAX(bfm_erst_in_ep_seq), MAX(bfm_letzt_in_ep_seq)
          INTO l_vers_seq, l_gem_seq, l_bfm_erst_in_ep_seq, l_bfm_letzt_in_ep_seq
          FROM
          (
            SELECT 
            COUNT(*) OVER (PARTITION BY finasi.versichertennummer) vers_seq, 
            COUNT(*) OVER (PARTITION BY finasi.gemeinde_id) gem_seq,
            COUNT(*) OVER (PARTITION BY finasi.bfm_status_erst_in_ep) bfm_erst_in_ep_seq,
            COUNT(*) OVER (PARTITION BY finasi.bfm_status_letzt_in_ep) bfm_letzt_in_ep_seq
            FROM finasi
            WHERE finasi.jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
            AND finasi.versichertennummer = x.versichertennummer
          );
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_vers_seq := 0;
        END;
                    
        IF  l_vers_seq = 1 OR (l_vers_seq = l_gem_seq AND l_vers_seq = l_bfm_erst_in_ep_seq AND l_vers_seq = l_bfm_letzt_in_ep_seq) THEN -- IF 1
        BEGIN
              -- Abgleich über Versichertennummer
            SELECT NVL(bfm_status_erst_in_ep,-9), NVL(bfm_status_letzt_in_ep, -9), finasi.jahr, finasi.symic_nr, finasi.dos_nr, finasi.pers_nr, finasi.dat_statuswechsel, finasi.nationalitaet
            INTO l_bfm_status_erst_in_ep, l_bfm_status_letzt_in_ep, l_jahr, l_symic_nr, l_doss_nr, l_pers_nr, l_dat_statuswechsel, l_finasi_nationalitaet
            FROM finasi
            WHERE finasi.jahr = (SELECT jahr FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
            AND versichertennummer = x.versichertennummer
            AND ROWNUM = 1;

              -- Regeln:
            -- Wenn Datum der letzten Zahlung < Statuswechsel => Aufenthaltstatus = bfm_status_erst_in_ep
            -- Sonst Aufenthaltstatus = l_bfm_status_letzt_in_ep
            IF  l_dat_letzte_zahlung < l_dat_statuswechsel THEN
                l_bfm_status := l_bfm_status_erst_in_ep;
            ELSE
                l_bfm_status := l_bfm_status_letzt_in_ep;
            END IF;

            SELECT COUNT(*) INTO l_cnt  FROM v_aufenthaltsstatus WHERE bfm_code = l_bfm_status;

            IF l_cnt > 0 THEN
                SELECT aufenthaltsstatus_id INTO l_aufenthaltsstatus_id FROM v_aufenthaltsstatus WHERE bfm_code = l_bfm_status;
            END IF;
         
            IF l_aufenthaltsstatus_id is null AND l_bfm_status IN (1,2,3) THEN
                l_aufenthaltsstatus_id := 7;
            END IF;

            IF l_aufenthaltsstatus_id IS NULL THEN
                l_aufenthaltsstatus_id := l_roh_aufenthaltsstatus_id_alt;
            END IF;

            IF p_wiederholung = 0 THEN
            BEGIN
               IF l_aufenthaltsstatus_id IS NOT NULL THEN
                  UPDATE ue_person SET aufenthaltsstatus_id = l_aufenthaltsstatus_id WHERE sh_dossier_id = p_sh_dossier_id AND ue_person_id = x.ue_person_id;
               END IF;
            END;
            END IF;

            l_finasi_log_id := NULL;

            IF p_wiederholung = 1 THEN
                l_result := FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id,  l_jahr, l_symic_nr, l_doss_nr, l_pers_nr,  x.ue_person_id, l_roh_aufenthaltsstatus_id_alt, x.aufenthaltsstatus_id, 1);
            ELSE
            BEGIN

                SELECT SQ_FINASILOG_ID.NEXTVAL
                INTO l_finasi_log_id
                FROM DUAL;

                INSERT INTO finasi_log (finasi_log_id, jahr, symic_nr, dos_nr, pers_nr, sh_dossier_id, ue_person_id, aufenthaltsstatus_id_alt, aufenthaltsstatus_id_neu, finasi_abgleich_status_id, b_erledigt, dat_erledigt, b_wiederholung)
                VALUES (l_finasi_log_id, l_jahr, l_symic_nr, l_doss_nr, l_pers_nr, p_sh_dossier_id, x.ue_person_id, l_roh_aufenthaltsstatus_id_alt, l_aufenthaltsstatus_id,1, 1, SYSDATE, 0);

            END;
            END IF;



        END; -- IF 2
        ELSE
           -- Kein Treffer für die UE-Person Dossier in FINASI, wenn Nationalitaet des Antragstellers = Ausländer und Aufenthaltsstatus = 14,15, dann Eintrag in FINASI-LOG mit nicht gefunden
           IF (x.nationalitaet_land_id > 0 OR x.nationalitaet_land_id = -1) AND x.nationalitaet_land_id <> 131 THEN
           BEGIN
                     IF p_wiederholung = 1 THEN
                          l_result := FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id,  l_jahr, NULL, NULL, NULL, x.ue_person_id, l_roh_aufenthaltsstatus_id_alt, x.aufenthaltsstatus_id, 4);
      
                     ELSE
                        IF x.aufenthaltsstatus_id IN (-1,7,14,15) THEN
                         
                          l_result := FC_INSERT_FINASI_LOG(p_sh_dossier_id, l_jahr, NULL, NULL, NULL, x.ue_person_id, l_roh_aufenthaltsstatus_id_alt, x.aufenthaltsstatus_id, 4, 0);
                                                  
                          UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
                          WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                          AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);
                       END IF;
                     END IF;

            END;
            END IF;

        END IF;
    END LOOP;

  EXCEPTION
  WHEN NO_DATA_FOUND THEN
  RAISE;
    RETURN;
END;

FUNCTION FC_INSERT_FINASI_LOG(p_sh_dossier_id INTEGER, p_jahr INTEGER, p_symic_nr INTEGER, p_doss_nr INTEGER, p_pers_nr INTEGER, p_ue_person_id INTEGER, p_aufenthaltsstatus_alt INTEGER, p_aufenthaltstatus_neu INTEGER, p_abgleich_status_id INTEGER, p_wiederholung INTEGER)
RETURN INTEGER
IS
  l_finasi_log_id INTEGER;
  
BEGIN

     SELECT SQ_FINASILOG_ID.NEXTVAL INTO
     l_finasi_log_id
     FROM DUAL;

     INSERT INTO finasi_log (finasi_log_id, jahr, symic_nr, dos_nr, pers_nr, sh_dossier_id,  ue_person_id, aufenthaltsstatus_id_alt, aufenthaltsstatus_id_neu, finasi_abgleich_status_id, b_wiederholung)
     VALUES (l_finasi_log_id, p_jahr, p_symic_nr, p_doss_nr, p_pers_nr, p_sh_dossier_id, p_ue_person_id, p_aufenthaltsstatus_alt, p_aufenthaltstatus_neu, p_abgleich_status_id,p_wiederholung);
          
     RETURN 0;
    
END;

FUNCTION FC_CHECK_FINASI_WIEDERHOLUNG(p_sh_dossier_id INTEGER, p_jahr INTEGER, p_symic_nr INTEGER, p_doss_nr INTEGER, p_pers_nr INTEGER, p_ue_person_id INTEGER, p_aufenthaltsstatus_alt INTEGER, p_prim_aufenthaltstatus_id INTEGER, p_abgleich_status_id INTEGER)
RETURN INTEGER
IS
 l_finasi_log_id INTEGER;
 l_fin_log_aufentstatus_neu_id INTEGER;
 l_result INTEGER;
BEGIN
   BEGIN
      
      SELECT finasi_log_id, aufenthaltsstatus_id_neu INTO l_finasi_log_id, l_fin_log_aufentstatus_neu_id FROM finasi_log 
      WHERE jahr = p_jahr AND sh_dossier_id = p_sh_dossier_id 
      AND DECODE(symic_nr, p_symic_nr, 0) is not null 
      AND DECODE(dos_nr, p_doss_nr, 0) is not null
      AND DECODE(pers_nr, p_pers_nr, 0) is not null
      AND DECODE(ue_person_id, p_ue_person_id , 0) is not null 
      AND b_wiederholung = 1;
      
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_finasi_log_id := NULL;
    END;
    
    IF ( l_finasi_log_id is not null) THEN
      IF p_prim_aufenthaltstatus_id <> l_fin_log_aufentstatus_neu_id THEN
          UPDATE finasi_log SET aufenthaltsstatus_id_neu = p_prim_aufenthaltstatus_id, finasi_abgleich_status_id = p_abgleich_status_id, b_wiederholung = 1, mut_dat = SYSDATE
          WHERE finasi_log_id = l_finasi_log_id;
          
          UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
          WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
          AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);
     
      END IF;
    ELSE
            BEGIN
                SELECT finasi_log_id, aufenthaltsstatus_id_neu INTO l_finasi_log_id, l_fin_log_aufentstatus_neu_id FROM finasi_log 
                WHERE jahr = p_jahr AND sh_dossier_id = p_sh_dossier_id 
                AND DECODE(symic_nr, p_symic_nr, 0) is not null 
                AND DECODE(dos_nr, p_doss_nr, 0) is not null
                AND DECODE(pers_nr, p_pers_nr, 0) is not null
                AND DECODE(ue_person_id, p_ue_person_id , 0) is not null 
                AND b_wiederholung = 0;
      
              EXCEPTION
              WHEN NO_DATA_FOUND THEN
              l_finasi_log_id := NULL;
            END;
            
            IF ( l_finasi_log_id is not null) THEN
              IF p_prim_aufenthaltstatus_id <> l_fin_log_aufentstatus_neu_id THEN
             
                  l_result := FC_INSERT_FINASI_LOG(p_sh_dossier_id, p_jahr, p_symic_nr, p_doss_nr, p_pers_nr, p_ue_person_id, p_aufenthaltsstatus_alt, p_prim_aufenthaltstatus_id, p_abgleich_status_id, 1);
                  
                    UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
                    WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                    AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);
                  
              END IF;
            ELSE
              IF p_abgleich_status_id = 4 THEN
                IF p_prim_aufenthaltstatus_id IN (-1,7,14,15) THEN
                  l_result := FC_INSERT_FINASI_LOG(p_sh_dossier_id, p_jahr, p_symic_nr, p_doss_nr, p_pers_nr, p_ue_person_id, p_aufenthaltsstatus_alt, p_prim_aufenthaltstatus_id, 4, 1);
              
                  UPDATE soz_traeger_lieferung SET b_zemis_kontrolle_notwendig = 1
                  WHERE soz_traeger_lieferung_id = (SELECT soz_traeger_lieferung_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id)
                  AND standort_id = (SELECT standort_id FROM sh_dossier WHERE sh_dossier_id = p_sh_dossier_id);
                END IF;
              END IF;   
            END IF;
    END IF;
    
    RETURN 0;
END;

/* --------------------------------------------------------------------------
   ISOS 5.0
   ********
   Version 1.00   02.09.2008   Oliver Heiler, Concevis AG
   Grund:         Abgleich Aufenthaltsstatus mit Finasi-Tabelle für alle Antragsteller

* -------------------------------------------------------------------------- */

PROCEDURE SP_UPD_AUFENTHALTSSTATUS_ALL AS

BEGIN

  FOR x IN
  (
    SELECT sh_dossier_id FROM antragsteller
  )
  LOOP

  SP_UPDATE_AUFENTHALTSSTATUS(x.sh_dossier_id, 0);

  END LOOP;

  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN;


END;




FUNCTION FC_FLUSTAT_GRUNDGESAMTHEIT(p_durchlauf_id INTEGER, p_soz_traeger_datenimport_id INTEGER, p_standort_id INTEGER)
RETURN INTEGER
IS
    l_table VARCHAR(20);
    l_stmt  VARCHAR(1024);
    l_ggfstat INTEGER;
    l_ggfstatue INTEGER;
    l_bfm_status INTEGER;

BEGIN
    l_ggfstat := NULL;

    FOR x IN
    (
        SELECT finasi_log.sh_dossier_id as dossid,  finasi_log.aufenthaltsstatus_id_neu as V0405, finasi_log.ue_person_id,
        finasi.dat_statuswechsel, finasi.bfm_status_erst_in_ep, finasi.bfm_status_letzt_in_ep, finasi.dat_erst_in_ep, finasi.dat_letzt_in_ep, sh_dossier.jahr FROM finasi_log
        INNER JOIN sh_dossier ON (sh_dossier.sh_dossier_id = finasi_log.sh_dossier_id)
        LEFT OUTER JOIN finasi ON (finasi_log.jahr = finasi.jahr AND finasi_log.symic_nr = finasi.symic_nr AND finasi_log.dos_nr = finasi.dos_nr AND finasi_log.pers_nr = finasi.pers_nr)
        WHERE sh_dossier.soz_traeger_datenimport_id = p_soz_traeger_datenimport_id AND sh_dossier.standort_id = p_standort_id
        AND finasi_abgleich_status_id IN (1,3,5)
        ORDER BY finasi_log.sh_dossier_id, finasi_log.ue_person_id DESC
    )
    LOOP

    -- Stufe 1
        IF x.dat_statuswechsel is null OR TO_CHAR(x.dat_statuswechsel) = '09.01.9999' THEN
            l_bfm_status := x.bfm_status_letzt_in_ep;
        ELSE
            l_bfm_status := x.bfm_status_erst_in_ep;
        END IF;

        IF l_bfm_status IN (4,8,12,16,18) OR x.V0405 IN (1,2,3) THEN l_ggfstat := 1;
        ELSIF l_bfm_status IN ( 11,13,14,15) THEN l_ggfstat := 2;
        ELSIF l_bfm_status IN (7,17) THEN l_ggfstat := 3;
        ELSIF l_bfm_status IN (1,2,3,5,6,9,10) THEN l_ggfstat := 0;
        END IF;

    -- Stufe 2
        IF (
             x.dat_statuswechsel <> TO_DATE('09.01.9999','DD.MM.YYYY')
             AND
             (
                (x.dat_erst_in_ep < TO_DATE('01.01.' || x.jahr, 'DD.MM.YYYY') OR x.dat_erst_in_ep > TO_DATE('31.01.' || x.jahr, 'DD.MM.YYYY'))
                OR
                (x.dat_letzt_in_ep < TO_DATE('01.12.' || x.jahr, 'DD.MM.YYYY') OR x.dat_letzt_in_ep > TO_DATE('31.12.' || x.jahr, 'DD.MM.YYYY') )
             )
           )
           THEN
                IF l_ggfstat = 2 THEN l_ggfstat := 4;
                ELSIF l_ggfstat = 3 THEN l_ggfstat := 5;
                END IF;
        END IF;

        -- Stufe 3
        IF x.ue_person_id is null THEN
            UPDATE antragsteller SET ggfstat = l_ggfstat, ggfstatue = l_ggfstat WHERE sh_dossier_id = x.dossid;
        ELSE
            BEGIN
                 UPDATE ue_person SET ggfstat = l_ggfstat WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
                 UPDATE ue_person SET ggfstatue = ( SELECT ggfstat FROM antragsteller WHERE  sh_dossier_id = x.dossid) WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
                 
                 BEGIN
                   SELECT ggfstatue INTO l_ggfstatue FROM ue_person WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
                
                 EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                    l_ggfstatue := NULL;
                 END;
                 
                 IF l_ggfstat <> l_ggfstatue THEN
                    UPDATE ue_person SET mispers = 1 WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
                 ELSE
                    UPDATE ue_person SET mispers = 0 WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
                 END IF;
            END;
        END IF;

        UPDATE sh_dossier SET misdoss = (SELECT NVL(SUM(mispers),0) FROM ue_person  WHERE sh_dossier_id = x.dossid)
        WHERE  sh_dossier_id = x.dossid;

    END LOOP;

    FOR x IN
    (
       SELECT finasi_log.sh_dossier_id as dossid, finasi_log.aufenthaltsstatus_id_neu as finasi, finasi_log.ue_person_id FROM finasi_log
        INNER JOIN sh_dossier ON (sh_dossier.sh_dossier_id = finasi_log.sh_dossier_id)
        WHERE sh_dossier.soz_traeger_datenimport_id = p_soz_traeger_datenimport_id AND sh_dossier.standort_id = p_standort_id
        AND finasi_abgleich_status_id = 4
        ORDER BY finasi_log.sh_dossier_id, finasi_log.ue_person_id DESC
    )
    LOOP

      IF x.ue_person_id is null THEN
         UPDATE antragsteller SET ggfstat = 1, ggfstatue = 1 WHERE sh_dossier_id = x.dossid;
      ELSE
         UPDATE ue_person SET ggfstat = 1, ggfstatue = 1, mispers = 0 WHERE sh_dossier_id = x.dossid AND ue_person_id = x.ue_person_id;
      END IF;

       UPDATE sh_dossier SET misdoss = (SELECT NVL(SUM(mispers),0) FROM ue_person  WHERE sh_dossier_id = x.dossid)
       WHERE  sh_dossier_id = x.dossid;

    END LOOP;


    RETURN 0;

END;

FUNCTION FC_FLUSTAT_COPY_CHECK(
                     p_durchlauf_id INTEGER,
                     p_import_id    INTEGER,
                     p_standort_id  INTEGER)
RETURN INTEGER

IS

l_result INTEGER;
l_count INTEGER;
l_fehler_id INTEGER;
l_fehler_nr v_fehler_test.fehler_nr%TYPE;
l_sql_stmt VARCHAR2(1024);
BEGIN

 l_fehler_nr := 'F6-11-1';

 l_sql_stmt :=
   'INSERT INTO stdi_fehler (
      soz_traeger_datenimport_id, soz_traeger_registration_id,
      soz_traeger_lieferung_id, standort_id, sh_dossier_id,
      fehler_id, fehler_nr)
   SELECT
      d.soz_traeger_datenimport_id, d.soz_traeger_registration_id,
      d.soz_traeger_lieferung_id, d.standort_id, :dossier_y_id,
      :fehler_id, :fehler_nr
   FROM sh_dossier d
   WHERE d.sh_dossier_id = :dossier_id ';

 -- Für den Probelauf gibt es nichts zu tun. Flüstat-Dossiers werden vor dem Reallauf kopiert und
 -- sind während des Probelaufs nocht nicht vorhanden nicht vorhanden

 IF (p_durchlauf_id = 0) THEN
   RETURN 0;
 END IF;

 DELETE FROM stdi_fehler
  WHERE sh_dossier_id IN (
     SELECT sh_dossier_id
     FROM sh_dossier d
     WHERE d.soz_traeger_datenimport_id = p_import_id
     AND d.standort_id = p_standort_id)
  AND fehler_id IN (
     SELECT fehler_id
     FROM v_fehler_test
     WHERE fehler_nr IN ( l_fehler_nr ));

 BEGIN

     SELECT f.fehler_id
     INTO l_fehler_id
     FROM v_fehler_test f
     WHERE f.fehler_nr = l_fehler_nr
     AND b_aktiv = 1;
       EXCEPTION
          WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20001, 'Es gibt keinen aktiven Fehlertest mit der Nummer F6-11-1');
 END;
     -- Ermittlung der kopierten Dossiers innerhalb der Lieferung
     FOR x IN
    (
        SELECT d.sh_dossier_id, a.versichertennummer, d.jahr, d.soz_traeger_datenimport_id FROM sh_dossier d
        INNER JOIN antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
        WHERE d.sh_flustat_id is not null
        AND d.soz_traeger_datenimport_id = p_import_id AND d.standort_id = p_standort_id
        AND d.dossier_status_id <> 5
    )
    LOOP

        -- Prüfen, ob für das kopierte Dossier ausserhalb der Lieferung ein Dublette gibt
        -- mit einem Antragsteller mit Aufenthaltsstatus 14 oder 15
        l_count := 0;

        FOR y IN
        (
             SELECT d.sh_dossier_id, a.versichertennummer FROM sh_dossier d
             INNER JOIN antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
             WHERE d.jahr = x.jahr AND a.aufenthaltsstatus_id IN (14,15)
             AND x.versichertennummer = a.versichertennummer
             AND d.dossier_status_id <> 5
             AND d.soz_traeger_datenimport_id <> x.soz_traeger_datenimport_id
        )
        LOOP
            l_count := l_count + 1;

            -- Fehler für das kopierte Dossier schreiben
            IF l_count = 1 THEN
                 EXECUTE IMMEDIATE l_sql_stmt
                 USING x.sh_dossier_id, l_fehler_id, l_fehler_nr, x.sh_dossier_id;
            END IF;

            -- Fehler für die gefundenen Dubletten schreiben
            EXECUTE IMMEDIATE l_sql_stmt
            USING y.sh_dossier_id, l_fehler_id, l_fehler_nr, x.sh_dossier_id;

        END LOOP;

    END LOOP;

    RETURN 0;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   08.05.2013   Oliver Heiler, Concevis AG
   Grund:         Ersetzt Fehlertest F6-1-11, neues Plausikonzept

* -------------------------------------------------------------------------- */

FUNCTION FC_FLUSTAT_COPY_CHECK_PLAUSI(iSelektionId INTEGER)
RETURN INTEGER

IS

l_result INTEGER;
l_count INTEGER;
l_plausimeldung_id INTEGER;
l_plausi_nr v_plausi.alpha_code%TYPE;
l_sql_stmt VARCHAR2(1024);
BEGIN

 l_plausi_nr := 'Afinasi-30';

 l_sql_stmt :=
   'INSERT INTO sh_dossier_plausi (
      sh_dossier_id, plausimeldung_id)
   SELECT
      :dossier_y_id,
      :plausimeldung_id
   FROM sh_dossier d
   WHERE d.sh_dossier_id = :dossier_id ';

 DELETE FROM sh_dossier_plausi
  WHERE sh_dossier_id IN (
      SELECT s.dossier_id FROM import_selektion s
      INNER JOIN sh_dossier d ON d.sh_dossier_id = s.dossier_id
      WHERE s.selektion_id = iSelektionId)
  AND plausimeldung_id IN (
     SELECT plausimeldung_id
     FROM v_plausi
     WHERE alpha_code = l_plausi_nr);

 BEGIN

     SELECT DISTINCT pm.plausimeldung_id
     INTO l_plausimeldung_id 
     FROM v_plausi p
     INNER JOIN v_plausimeldung pm ON (pm.plausi_id = p.plausi_id)
     WHERE p.alpha_code = l_plausi_nr;
     
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20001, 'Es gibt keine Plausi-Regel mit der Nummer ' || l_plausi_nr);
 END;
     -- Ermittlung der kopierten Dossiers innerhalb der Lieferung
     FOR x IN
    (
        SELECT d.sh_dossier_id, a.versichertennummer, d.jahr, d.soz_traeger_datenimport_id FROM sh_dossier d
        INNER JOIN antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
        INNER JOIN import_selektion s ON (s.selektion_id = d.sh_dossier_id)
        WHERE s.selektion_id = iSelektionId
        AND d.sh_flustat_id is not null
        AND d.dossier_status_id <> 5
    )
    LOOP

        -- Prüfen, ob für das kopierte Dossier ausserhalb der Lieferung ein Dublette gibt
        -- mit einem Antragsteller mit Aufenthaltsstatus 14 oder 15
        l_count := 0;

        FOR y IN
        (
             SELECT d.sh_dossier_id, a.versichertennummer FROM sh_dossier d
             INNER JOIN antragsteller a ON (a.sh_dossier_id = d.sh_dossier_id)
             WHERE d.jahr = x.jahr AND a.aufenthaltsstatus_id IN (14,15)
             AND x.versichertennummer = a.versichertennummer
             AND d.dossier_status_id <> 5
             AND d.soz_traeger_datenimport_id <> x.soz_traeger_datenimport_id
        )
        LOOP
            l_count := l_count + 1;

            -- Fehler für das kopierte Dossier schreiben
            IF l_count = 1 THEN
                 EXECUTE IMMEDIATE l_sql_stmt
                 USING x.sh_dossier_id, l_plausimeldung_id, x.sh_dossier_id;
            END IF;

            -- Fehler für die gefundenen Dubletten schreiben
            EXECUTE IMMEDIATE l_sql_stmt
            USING y.sh_dossier_id, l_plausimeldung_id, x.sh_dossier_id;

        END LOOP;

    END LOOP;

    RETURN 0;
END;

/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   21.03.2013   Oliver Heiler, Concevis AG
   Grund:         Kopiert Flüstat Dossiers mit 6 Monate Regel in die angegebene EP

* -------------------------------------------------------------------------- */
PROCEDURE SP_COPY_FLUSTAT_DOSSIERS ( p_kanton_id v_kanton.kanton_id%TYPE, p_jahr_ep INTEGER )
IS
  l_prev_sl_traeger_id INTEGER;
  l_cur_sl_traeger_id INTEGER;
  
  l_ep_lieferung_id INTEGER;
  l_ep_registration_id INTEGER;
  l_ep_datenimport_id INTEGER;
  l_ep_standort_id INTEGER;
    
  TYPE DOSS is RECORD ( sh_dossier_id INTEGER);
  TYPE DOSS_TABLE is TABLE OF DOSS;
  l_doss_rec  DOSS_TABLE;
  
  l_6_month_rule_query CLOB;
  
BEGIN
  
  FOR x IN
  (
    SELECT s.sozialleistungstraeger_id, sl.soz_traeger_lieferung_id, sl.standort_id 
    FROM  sozialleistungstraeger s
    JOIN soz_traeger_lieferung sl ON sl.sozialleistungstraeger_id = s.sozialleistungstraeger_id
    WHERE sl.kanton_id = p_kanton_id AND sl.jahr = p_jahr_ep-1
    ORDER BY s.sozialleistungstraeger_id
  )
  LOOP
       -- Kopiere alle Dossiers der Lieferung EP-1 des Sozialleistungstraegers, welche der 6 Monate-Regel entsprechen in den gefundenen ersten Datenimport
       -- der angegebenen EP
        l_6_month_rule_query := 
          ' SELECT dos.sh_dossier_id FROM
            sh_dossier dos
            JOIN sozialleistungstraeger ON sozialleistungstraeger.sozialleistungstraeger_id = dos.sozialleistungstraeger_id
            JOIN v_kanton ON v_kanton.kanton_id = sozialleistungstraeger.kanton_id
            WHERE dos.jahr = :ep_minus
            AND dos.soz_traeger_lieferung_id = :liefer_id 
            AND dos.standort_id = :standort_id
            AND dos.b_neubezuegerrecord = 1
            AND dos.dossier_status_id <> 5
            AND dos.sh_leistungstyp_id between 1 AND 5
            AND dos.sh_flustat_id is not null
            AND dos.dat_letzte_zahlung > TO_DATE(''30.06'' || :ep_minus, ''DD.MM.YYYY'')  
            AND dos.dat_letzte_zahlung <= TO_DATE(''31.12'' || :ep_minus, ''DD.MM.YYYY'')  
            AND v_kanton.kanton_id = :kanton_id';
        
       BEGIN
          EXECUTE IMMEDIATE l_6_month_rule_query BULK COLLECT INTO l_doss_rec USING  p_jahr_ep-1,  x.soz_traeger_lieferung_id, x.standort_id, p_jahr_ep-1, p_jahr_ep-1,  p_kanton_id;
          
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_ep_datenimport_id := NULL;
       END;
            
      -- Finde den ersten Datenimport des Sozialleistungstraeger in der angegebenen EP
      IF l_doss_rec.count() > 0 THEN
        BEGIN
            SELECT soz_traeger_datenimport.soz_traeger_lieferung_id, soz_traeger_datenimport.soz_traeger_registration_id, soz_traeger_datenimport.soz_traeger_datenimport_id, soz_traeger_datenimport.standort_id 
            INTO l_ep_lieferung_id, l_ep_registration_id, l_ep_datenimport_id, l_ep_standort_id
            FROM soz_traeger_datenimport
            JOIN soz_traeger_lieferung ON soz_traeger_lieferung.soz_traeger_lieferung_id = soz_traeger_datenimport.soz_traeger_lieferung_id
            JOIN sozialleistungstraeger ON sozialleistungstraeger.sozialleistungstraeger_id = soz_traeger_lieferung.sozialleistungstraeger_id
            WHERE sozialleistungstraeger.sozialleistungstraeger_id = x.sozialleistungstraeger_id AND soz_traeger_lieferung.jahr = p_jahr_ep
            AND rownum = 1
            ORDER BY soz_traeger_datenimport_id, standort_id;
        
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              l_ep_datenimport_id := null;
        END;
        
        IF l_ep_datenimport_id IS NOT NULL THEN
          BEGIN
              FOR i in 1..l_doss_rec.COUNT
              LOOP
                DO_FLUSTAT.SP_COPY_FLUSTAT_DOSSIER( l_doss_rec(i).sh_dossier_id, l_ep_datenimport_id, l_ep_standort_id);
              END LOOP;
          END;
        ELSE
          BEGIN
           FOR i in 1..l_doss_rec.COUNT
              LOOP
                INSERT INTO flustat_kopie_history (ep_minus_1_sh_dossier_id, kanton_id, soz_traeger_datenimport_id, standort_id, ep_sh_dossier_id)
                VALUES ( l_doss_rec(i).sh_dossier_id, p_kanton_id, NULL, NULL, NULL);
              END LOOP;
          END;
        
        END IF;
     END IF;
     
     l_doss_rec.delete();
   
  END LOOP;
  
    COMMIT;   
END;
/* --------------------------------------------------------------------------
   ISOS 6.4
   ********
   Version 1.00   24.03.2013   Oliver Heiler, Concevis AG
   Grund:         Kopiert das Dossier für die angegebene Dossier-ID in den 
                  angegebenen Ziel-Datenimport mit neuer Dossier-ID und Jahr+1 in die Sekundärdaten

* -------------------------------------------------------------------------- */
PROCEDURE SP_COPY_FLUSTAT_DOSSIER ( 
    p_sh_dossier_id sec_sh_dossier.sh_dossier_id%TYPE,
    p_datenimport_id soz_traeger_datenimport.soz_traeger_datenimport_id%TYPE, 
    p_standort_id  soz_traeger_datenimport.standort_id%TYPE)
IS
  l_new_sh_dossier_id INTEGER;
  l_ep_lieferung_id INTEGER;
  l_ep_registration_id INTEGER;
  l_ep_kanton_id INTEGER;
  l_ep_jahr INTEGER;
  
BEGIN
  SELECT NEXT_ID.NEXTVAL INTO l_new_sh_dossier_id FROM DUAL;

  SELECT d.soz_traeger_lieferung_id, d.soz_traeger_registration_id, l.kanton_id, l.jahr INTO l_ep_lieferung_id, l_ep_registration_id, l_ep_kanton_id, l_ep_jahr
  FROM soz_traeger_datenimport d
  JOIN soz_traeger_lieferung l ON l.soz_traeger_lieferung_id = d.soz_traeger_lieferung_id AND l.standort_id = d.standort_id
  WHERE d.soz_traeger_datenimport_id = p_datenimport_id AND d.standort_id = p_standort_id;
  
  INSERT INTO SEC_SH_DOSSIER (SH_DOSSIER_ID,JAHR,GEMEINDE_ID,SOZIALLEISTUNGSTRAEGER_ID,SH_LEISTUNGSTYP_ID,DOSSIERNUMMER,B_NEUBEZUEGERRECORD,WOHNUNGSGROESSE_ID,SH_WOHNSITUATION_ID,SH_LEISTUNGSART_ID,
  BEENDIGUNGSGRUND_ID,ANTRAGSART_ID,PFLEGER_ID,SH_HAUSHALT_ID,DAT_AUFNAHME,ANZ_PERSONEN_HH,ANZ_PERSONEN_UE,ANZ_PFLEGEFAELLE_HH,B_WEITERE_UE_EINKOMMEN,B_VERMOEGENSFREIBETRAG,
  B_GUTHABEN_PENSIONSKASSE,B_WOHNEIGENTUM,B_FRUEHER_UNTERSTUETZT,DAUER_UNTERSTUETZUNG_MT,WOHNKOSTEN_INKL_NK,BETRAG_BRUTTOBEDARF,BETRAG_NETTOBEDARF_SKOS,BETRAG_ZUGESPROCHEN,
  DAT_ERSTE_AUSZAHLUNG,BETRAG_TOT_EINMALZAHLUNGEN,BETRAG_TOT_AUSZAHLUNGEN,B_BEZUG_STICHTAG,DAT_LETZTE_ZAHLUNG,B_UEBERBRUECKUNG,DAT_ABGESCHLOSSEN,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,
  UE_MONATSEINKOMMEN,UE_MONATSERWERBSEINKOMMEN,UE_MONATSSOZIALVERSLEISTUNGEN,UE_MONATSLEISTUNGEN_BEDARF,UE_JAHRESNETTOEINKOMMEN,UE_JAHRESSTEUEREINKOMMEN,EINKOMMEN_DETAIL_ID,SOZ_TRAEGER_DATENIMPORT_ID,
  SOZ_TRAEGER_REGISTRATION_ID,SOZ_TRAEGER_LIEFERUNG_ID,STANDORT_ID,DOSSIER_STATUS_ID,DUBLETTE_ID,STATUS_AKTION_ID,B_BER_SKOS_2005,BETRAG_TOT_AUSZ_KRANKHEIT,UE_MONATS_ZUSATZEINKOMMEN,DAT_BEGINN_ANSPRUCH,
  B_ERGAENZUNG_BUND,BETRAG_ZUGESPROCHEN_EL_BUND,BETRAG_AUSBEZAHLT_EL_BUND,B_BEIHILFE_KANTON,BETRAG_ZUGESPR_BEIHILFE_KANTON,BETRAG_AUSBEZ_BEIHILFE_KANTON,B_ZUSCHUSS_GEMEINDE,BETRAG_ZUGESPR_ZUSCHUSS_GEM,
  BETRAG_AUSBEZ_ZUSCHUSS_GEM,MUT_USERNAME,INS_USERNAME,GRUND_DOSSIER_LOESCHUNG_ID,SH_FREMD_ID,MISDOSS,SH_FLUSTAT_ID,MUT_STATUS_USER_ID,COPY_TOKEN) 
  SELECT 
  l_new_sh_dossier_id, l_ep_jahr,GEMEINDE_ID,SOZIALLEISTUNGSTRAEGER_ID,SH_LEISTUNGSTYP_ID,DOSSIERNUMMER,B_NEUBEZUEGERRECORD,WOHNUNGSGROESSE_ID,SH_WOHNSITUATION_ID,SH_LEISTUNGSART_ID,
  BEENDIGUNGSGRUND_ID,ANTRAGSART_ID,PFLEGER_ID,SH_HAUSHALT_ID,DAT_AUFNAHME,ANZ_PERSONEN_HH,ANZ_PERSONEN_UE,ANZ_PFLEGEFAELLE_HH,B_WEITERE_UE_EINKOMMEN,B_VERMOEGENSFREIBETRAG,
  B_GUTHABEN_PENSIONSKASSE,B_WOHNEIGENTUM,B_FRUEHER_UNTERSTUETZT,DAUER_UNTERSTUETZUNG_MT,WOHNKOSTEN_INKL_NK,BETRAG_BRUTTOBEDARF,BETRAG_NETTOBEDARF_SKOS,BETRAG_ZUGESPROCHEN,
  DAT_ERSTE_AUSZAHLUNG,BETRAG_TOT_EINMALZAHLUNGEN,-8 /*betrag_tot_auszahlungen*/, 2 /* b_bezug_stichtag*/, DAT_LETZTE_ZAHLUNG,B_UEBERBRUECKUNG, ADD_MONTHS(DAT_LETZTE_ZAHLUNG, 6) /*dat_abgeschlossen*/, B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,
  UE_MONATSEINKOMMEN,UE_MONATSERWERBSEINKOMMEN,UE_MONATSSOZIALVERSLEISTUNGEN,UE_MONATSLEISTUNGEN_BEDARF,UE_JAHRESNETTOEINKOMMEN,UE_JAHRESSTEUEREINKOMMEN,EINKOMMEN_DETAIL_ID,p_datenimport_id,
  l_ep_registration_id, l_ep_lieferung_id, p_standort_id,DOSSIER_STATUS_ID,DUBLETTE_ID,STATUS_AKTION_ID,B_BER_SKOS_2005,BETRAG_TOT_AUSZ_KRANKHEIT,UE_MONATS_ZUSATZEINKOMMEN,DAT_BEGINN_ANSPRUCH,
  B_ERGAENZUNG_BUND,BETRAG_ZUGESPROCHEN_EL_BUND,BETRAG_AUSBEZAHLT_EL_BUND,B_BEIHILFE_KANTON,BETRAG_ZUGESPR_BEIHILFE_KANTON,BETRAG_AUSBEZ_BEIHILFE_KANTON,B_ZUSCHUSS_GEMEINDE,BETRAG_ZUGESPR_ZUSCHUSS_GEM,
  BETRAG_AUSBEZ_ZUSCHUSS_GEM,MUT_USERNAME,INS_USERNAME,GRUND_DOSSIER_LOESCHUNG_ID,SH_FREMD_ID,MISDOSS,SH_FLUSTAT_ID,MUT_STATUS_USER_ID,COPY_TOKEN
  FROM SH_DOSSIER WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_ANTRAGSTELLER (SH_DOSSIER_ID,GESCHLECHT_ID,ZIVILSTAND_ID,NATIONALITAET_LAND_ID,AUFENTHALTSSTATUS_ID,BUERGER_GEMEINDE_ID,ZUZUG_GEM_GEMEINDE_ID,ZUZUG_GEM_LAND_ID,ZUZUG_KANT_KANTON_ID,
  ZUZUG_KANT_LAND_ID,ZVR_GEMEINDE_ID,UST_GEMEINDE_ID,AUF_GEMEINDE_ID,AUSBILDUNG_ID,ABGEBR_AUSBILDUNG_ID,ERLERNTER_BERUF_ID,AKTUELLER_BERUF_ID,BESCHAEFTIGUNGSGRAD_ID,BRANCHE_ID,TEILZEIT_GRUND1_ID,
  TEILZEIT_GRUND2_ID,INVALIDITAETSGRAD_ID,HILFLOSIGKEITSGRAD_ID,AHV_NR8,AHV_NR3,DAT_GEBURT,DAT_IN_GEMEINDE_SEIT,DAT_IM_KANTON_SEIT,IN_CH_SEIT_JAHR,B_ALLEIN_IM_HH,B_ARBEIT_UNREGELMAESSIG,ARBEITSZEIT_WOCHE,
  DAT_STEMPELBEGINN,B_AUSGESTEUERT,DAT_AUSGESTEUERT,ANZ_ARBEITSLOS_3J,B_AUSB_ABGEBROCHEN,B_IV_EINGLIEDERUNG,B_KK_GRUNDVERSICHERUNG,B_KK_ZUSATZVERSICHERUNG,KK_NAME,KK_PRAEMIE_MT,
  B_KK_PRAEMIENZUSCHUSS,KK_ZUSCHUSS_BETRAG,BETRAG_MIETANTEIL,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,ZVR_STRASSE,ZVR_HAUS_NR,ZVR_ORT,ZVR_PLZ,UST_ORT,UST_PLZ,AUF_ORT,AUF_PLZ,VERSICHERTENNUMMER,
  MUT_USERNAME,AHV_NR8_DECODE,AHV_NR3_DECODE,GGFSTAT,GGFSTATUE,MUT_DAT_AUFENTHALTSSTATUS,MUT_USER_AUFENTHALTSSTATUS,MUT_USER_VERSICHERTENNUMMER,MUT_DAT_VERSICHERTENNUMMER) 
  SELECT 
  l_new_sh_dossier_id,GESCHLECHT_ID,ZIVILSTAND_ID,NATIONALITAET_LAND_ID,AUFENTHALTSSTATUS_ID,BUERGER_GEMEINDE_ID,ZUZUG_GEM_GEMEINDE_ID,ZUZUG_GEM_LAND_ID,ZUZUG_KANT_KANTON_ID,
  ZUZUG_KANT_LAND_ID,ZVR_GEMEINDE_ID,UST_GEMEINDE_ID,AUF_GEMEINDE_ID,AUSBILDUNG_ID,ABGEBR_AUSBILDUNG_ID,ERLERNTER_BERUF_ID,AKTUELLER_BERUF_ID,BESCHAEFTIGUNGSGRAD_ID,BRANCHE_ID,TEILZEIT_GRUND1_ID,
  TEILZEIT_GRUND2_ID,INVALIDITAETSGRAD_ID,HILFLOSIGKEITSGRAD_ID,AHV_NR8,AHV_NR3,DAT_GEBURT,DAT_IN_GEMEINDE_SEIT,DAT_IM_KANTON_SEIT,IN_CH_SEIT_JAHR,B_ALLEIN_IM_HH,B_ARBEIT_UNREGELMAESSIG,ARBEITSZEIT_WOCHE,
  DAT_STEMPELBEGINN,B_AUSGESTEUERT,DAT_AUSGESTEUERT,ANZ_ARBEITSLOS_3J,B_AUSB_ABGEBROCHEN,B_IV_EINGLIEDERUNG,B_KK_GRUNDVERSICHERUNG,B_KK_ZUSATZVERSICHERUNG,KK_NAME,KK_PRAEMIE_MT,
  B_KK_PRAEMIENZUSCHUSS,KK_ZUSCHUSS_BETRAG,BETRAG_MIETANTEIL,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,ZVR_STRASSE,ZVR_HAUS_NR,ZVR_ORT,ZVR_PLZ,UST_ORT,UST_PLZ,AUF_ORT,AUF_PLZ,VERSICHERTENNUMMER,
  MUT_USERNAME,AHV_NR8_DECODE,AHV_NR3_DECODE,GGFSTAT,GGFSTATUE,MUT_DAT_AUFENTHALTSSTATUS,MUT_USER_AUFENTHALTSSTATUS,MUT_USER_VERSICHERTENNUMMER,MUT_DAT_VERSICHERTENNUMMER
  FROM ANTRAGSTELLER WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_ANTRAGSTELLER_ALBV (ANTRAGSTELLER_ALBV_ID,ANTRAGSART_ID,SH_DOSSIER_ID,BETRAG_ZUGESPROCHEN,DAT_ERSTE_AUSZAHLUNG,betrag_tot_auszahlungen,B_BEZUG_STICHTAG,DAT_LETZTE_ZAHLUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MUT_USERNAME) 
  SELECT ANTRAGSTELLER_ALBV_ID,ANTRAGSART_ID,l_new_sh_dossier_id,BETRAG_ZUGESPROCHEN,DAT_ERSTE_AUSZAHLUNG,betrag_tot_auszahlungen,B_BEZUG_STICHTAG,DAT_LETZTE_ZAHLUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,NULL
  FROM ANTRAGSTELLER_ALBV  WHERE sh_dossier_id = p_sh_dossier_id;
 
  INSERT INTO SEC_ANTRAGSTELLER_BEDARF (ANTRAGSTELLER_BEDARF_ID,BEDARFSART_ID,SH_DOSSIER_ID,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MASSNAHME_GRUND_ID,MUT_USERNAME) 
  SELECT ANTRAGSTELLER_BEDARF_ID,BEDARFSART_ID,l_new_sh_dossier_id,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,MASSNAHME_GRUND_ID, NULL
  FROM ANTRAGSTELLER_BEDARF WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_ANTRAGSTELLER_EINKOMMEN (EINKOMMENSART_ID,SH_DOSSIER_ID,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,ANTRAGSTELLER_EINKOMMEN_ID,MUT_USERNAME) 
  SELECT EINKOMMENSART_ID,l_new_sh_dossier_id,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,ANTRAGSTELLER_EINKOMMEN_ID,NULL
  FROM ANTRAGSTELLER_EINKOMMEN  WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_ANTRAGSTELLER_ERWERBSIT (ERWERBSITUATION_ID,SH_DOSSIER_ID,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,ANTRAGSTELLER_ERWERBSIT_ID,MUT_USERNAME,INDX) 
  SELECT ERWERBSITUATION_ID,l_new_sh_dossier_id,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,ANTRAGSTELLER_ERWERBSIT_ID,NULL,INDX
  FROM ANTRAGSTELLER_ERWERBSIT WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_HH_PERSON (HH_PERSON_ID,SH_DOSSIER_ID,VERWANDTSCHAFTSGRAD_ID,B_SEPARATE_UNTERSTUETZUNG,AHV_NR8,AHV_NR3,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,VERSICHERTENNUMMER,MUT_USERNAME)
  SELECT HH_PERSON_ID,l_new_sh_dossier_id,VERWANDTSCHAFTSGRAD_ID,B_SEPARATE_UNTERSTUETZUNG,AHV_NR8,AHV_NR3,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,VERSICHERTENNUMMER,NULL
  FROM HH_PERSON WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_AUSGABE (AUSGABEART_ID,SH_DOSSIER_ID,BETRAG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,SH_AUSGABE_ID,B_IN_ABKLAERUNG,MUT_USERNAME)
  SELECT AUSGABEART_ID,l_new_sh_dossier_id,BETRAG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,SH_AUSGABE_ID,B_IN_ABKLAERUNG,NULL
  FROM  SH_AUSGABE WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_AUSZAHLUNG_MONAT (SH_DOSSIER_ID,MONAT_ID,BETRAG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,SH_AUSZAHLUNG_MONAT_ID,MUT_USERNAME) 
  SELECT l_new_sh_dossier_id,MONAT_ID,-8,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,SH_AUSZAHLUNG_MONAT_ID,NULL
  FROM SH_AUSZAHLUNG_MONAT WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_BEDARF (BEDARFSART_ID,SH_DOSSIER_ID,BETRAG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,SH_BEDARF_ID,MUT_USERNAME)
  SELECT BEDARFSART_ID,l_new_sh_dossier_id,BETRAG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,SH_BEDARF_ID,NULL
  FROM SH_BEDARF WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_MASSNAHME (MASSNAHME_ID,SH_DOSSIER_ID,KOMMENTAR,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,SH_MASSNAHME_ID,MUT_USERNAME) 
  SELECT MASSNAHME_ID,l_new_sh_dossier_id,KOMMENTAR,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,SH_MASSNAHME_ID,NULL
  FROM SH_MASSNAHME WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_MERKMAL (SH_DOSSIER_ID,SH_MERKMAL_ID,WERT,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MERKMAL_ID,MUT_USERNAME) 
  SELECT l_new_sh_dossier_id,SH_MERKMAL_ID,WERT,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,MERKMAL_ID,NULL
  FROM SH_MERKMAL  WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_WBSL_EINKOMMEN (SH_WBSL_EINKOMMEN_ID,SH_DOSSIER_ID,SH_EINKOMMENSART_ID,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MUT_USERNAME) 
  SELECT SH_WBSL_EINKOMMEN_ID,l_new_sh_dossier_id,SH_EINKOMMENSART_ID,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,NULL
  FROM SH_WBSL_EINKOMMEN  WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_SH_ZUSATZEINKOMMEN (SH_EINKOMMENSART_ID,SH_DOSSIER_ID,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,SH_ZUSATZEINKOMMEN_ID,MUT_USERNAME) 
  SELECT SH_EINKOMMENSART_ID,l_new_sh_dossier_id,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,SH_ZUSATZEINKOMMEN_ID,NULL
  FROM SH_ZUSATZEINKOMMEN WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_UE_PERSON (UE_PERSON_ID,SH_DOSSIER_ID,NATIONALITAET_LAND_ID,AUSBILDUNG_ID,GESCHLECHT_ID,ZIVILSTAND_ID,VERWANDTSCHAFTSGRAD_ID,AUFENTHALTSSTATUS_ID,BESCHAEFTIGUNGSGRAD_ID,
  INVALIDITAETSGRAD_ID,HILFLOSIGKEITSGRAD_ID,GEBURTSJAHR,IN_CH_SEIT_JAHR,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MUT_USERNAME,VERSICHERTENNUMMER,GGFSTAT,GGFSTATUE,MISPERS,MUT_DAT_AUFENTHALTSSTATUS,
  MUT_USER_AUFENTHALTSSTATUS,MUT_USER_VERSICHERTENNUMMER,MUT_DAT_VERSICHERTENNUMMER)
  SELECT UE_PERSON_ID,l_new_sh_dossier_id,NATIONALITAET_LAND_ID,AUSBILDUNG_ID,GESCHLECHT_ID,ZIVILSTAND_ID,VERWANDTSCHAFTSGRAD_ID,AUFENTHALTSSTATUS_ID,BESCHAEFTIGUNGSGRAD_ID,
  INVALIDITAETSGRAD_ID,HILFLOSIGKEITSGRAD_ID,GEBURTSJAHR,IN_CH_SEIT_JAHR,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,NULL,VERSICHERTENNUMMER,GGFSTAT,GGFSTATUE,MISPERS,MUT_DAT_AUFENTHALTSSTATUS,
  MUT_USER_AUFENTHALTSSTATUS,MUT_USER_VERSICHERTENNUMMER,MUT_DAT_VERSICHERTENNUMMER
  FROM UE_PERSON WHERE sh_dossier_id = p_sh_dossier_id;
    
  INSERT INTO SEC_ue_person_albv (UE_PERSON_ALBV_ID,SH_DOSSIER_ID,UE_PERSON_ID,ANTRAGSART_ID,BETRAG_ZUGESPROCHEN,DAT_ERSTE_AUSZAHLUNG,betrag_tot_auszahlungen,B_BEZUG_STICHTAG,
  DAT_LETZTE_ZAHLUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MUT_USERNAME) 
  SELECT UE_PERSON_ALBV_ID,l_new_sh_dossier_id, UE_PERSON_ID,ANTRAGSART_ID,BETRAG_ZUGESPROCHEN,DAT_ERSTE_AUSZAHLUNG,betrag_tot_auszahlungen,B_BEZUG_STICHTAG,
  DAT_LETZTE_ZAHLUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,NULL
  FROM ue_person_albv WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_UE_PERSON_BEDARF (UE_PERSON_BEDARF_ID,BEDARFSART_ID,UE_PERSON_ID,SH_DOSSIER_ID,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,MASSNAHME_GRUND_ID,MUT_USERNAME) 
  SELECT UE_PERSON_BEDARF_ID,BEDARFSART_ID,UE_PERSON_ID,l_new_sh_dossier_id,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,MASSNAHME_GRUND_ID,NULL
  FROM UE_PERSON_BEDARF WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO SEC_UE_PERSON_EINKOMMEN (UE_PERSON_ID,EINKOMMENSART_ID,SH_DOSSIER_ID,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,UE_PERSON_EINKOMMEN_ID,MUT_USERNAME)
  SELECT UE_PERSON_ID,EINKOMMENSART_ID,l_new_sh_dossier_id,BETRAG,B_IN_ABKLAERUNG,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,UE_PERSON_EINKOMMEN_ID,NULL
  FROM UE_PERSON_EINKOMMEN WHERE sh_dossier_id = p_sh_dossier_id;

  INSERT INTO SEC_UE_PERSON_ERWERBSIT (UE_PERSON_ID,ERWERBSITUATION_ID,SH_DOSSIER_ID,B_PLAUSIPROBLEM,INS_DAT,MUT_DAT,MUT_USR,UE_PERSON_ERWERBSIT_ID,MUT_USERNAME,INDX) 
  SELECT UE_PERSON_ID,ERWERBSITUATION_ID,l_new_sh_dossier_id,B_PLAUSIPROBLEM,SYSDATE,NULL,NULL,UE_PERSON_ERWERBSIT_ID,NULL,INDX
  FROM UE_PERSON_ERWERBSIT WHERE sh_dossier_id = p_sh_dossier_id;
  
  INSERT INTO flustat_kopie_history (ep_minus_1_sh_dossier_id, kanton_id, soz_traeger_datenimport_id, standort_id, ep_sh_dossier_id)
  VALUES ( p_sh_dossier_id, l_ep_kanton_id, p_datenimport_id, p_standort_id, l_new_sh_dossier_id);
                

END;
   -- Enter further code below as specified in the Package spec.
END;
/

create or replace 
PACKAGE BODY      do_secondardaten
IS

PROCEDURE sp_copy_sh_dossier_complete(p_datenimport_id IN INTEGER, p_standort_id IN INTEGER)
IS
    
BEGIN

    INSERT INTO SEC_SH_DOSSIER SELECT * FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id;
    INSERT INTO SEC_ANTRAGSTELLER SELECT * FROM ANTRAGSTELLER WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_ANTRAGSTELLER_ALBV SELECT * FROM ANTRAGSTELLER_ALBV WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_ANTRAGSTELLER_BEDARF SELECT * FROM ANTRAGSTELLER_BEDARF WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_ANTRAGSTELLER_EINKOMMEN SELECT * FROM ANTRAGSTELLER_EINKOMMEN WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_ANTRAGSTELLER_ERWERBSIT SELECT * FROM ANTRAGSTELLER_ERWERBSIT WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_HH_PERSON SELECT * FROM HH_PERSON WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_MASSNAHME SELECT * FROM SH_MASSNAHME WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_MERKMAL SELECT * FROM SH_MERKMAL WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_AUSGABE SELECT * FROM SH_AUSGABE WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_AUSZAHLUNG_MONAT SELECT * FROM SH_AUSZAHLUNG_MONAT WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_BEDARF SELECT * FROM SH_BEDARF WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_ZUSATZEINKOMMEN SELECT * FROM SH_ZUSATZEINKOMMEN WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_UE_PERSON SELECT * FROM UE_PERSON WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_UE_PERSON_ALBV SELECT * FROM UE_PERSON_ALBV WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_UE_PERSON_BEDARF SELECT * FROM UE_PERSON_BEDARF WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_UE_PERSON_EINKOMMEN SELECT * FROM UE_PERSON_EINKOMMEN WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_UE_PERSON_ERWERBSIT SELECT * FROM UE_PERSON_ERWERBSIT WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);
    INSERT INTO SEC_SH_WBSL_EINKOMMEN SELECT * FROM SH_WBSL_EINKOMMEN WHERE sh_dossier_id IN ( SELECT sh_dossier_id FROM SH_DOSSIER WHERE soz_traeger_datenimport_id = p_datenimport_id AND standort_id = p_standort_id);

END;

END;
/
